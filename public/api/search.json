[{"id":"5add787e344d5502fefa25471add4e2d","title":"Web前端性能优化","content":"1、前置知识面试题：输入url到页面最终呈现都发生了什么？\n\nurl解析：判断输入是关键字搜索还是url访问，对url进行解析\ndns域名解析获取ip地址\n缓存查找：浏览器缓存（chrome://net-internals/#dns地址查看）、系统缓存(hosts)、路由器缓存、isp缓存\n向本地DNS服务器发送查询报文”query zh.wikipedia.org”\n本地DNS服务器检查自身缓存，存在返回，不存在向根域名服务器发送查询报文”query zh.wikipedia.org”，得到顶级域 .org 的顶级域名服务器地址\nDNS服务器向 .org 域的顶级域名服务器发送查询报文”query zh.wikipedia.org”，得到二级域 .wikipedia.org 的权威域名服务器地址\nDNS服务器向 .wikipedia.org 域的权威域名服务器发送查询报文”query zh.wikipedia.org”，得到主机 zh 的A记录，存入自身缓存并返回给客户端\n\n\n使用IP建立TCP链接（三次握手）\n第一次握手： 建立连接时，客户端发送SYN标记的数据包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；\n第二次握手： 服务器收到SYN标记的数据包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n第三次握手： 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n\n\n发送http请求，服务器响应，缓存判断（强缓存和协商缓存）\n请求：发送命令+发送请求头信息+空白行+请求体（post）\n响应：响应状态 + 响应头+空白行+响应体\n强缓存：cache-control（max-age）、Expires\n协商缓存：返回Etag、Last-modified和请求IF-none-match、IF-modified-since\n\n\n浏览器解析渲染页面\n解析HTML，构建dom树，词法分析和语法分析\n解析css，生成css规则树，从右往左解析\n合并DOM树和CSS规则树，生成render树\n布局render树，根据render节点的类型，确定元素大小和位置\n绘制render树，绘制页面像素信息\n浏览器将各层的信息发送给GUI，GUI将各层合成，展示在屏幕上\n细化流程：构件dom树、构建sytle Rules、样式计算、创建布局树、分层、绘制、分块和光栅化、合成和显示\n渲染是在渲染进程执⾏的，渲染进程分为渲染主线程、光栅线程、合成线程等\n从分块阶段开始，包括分块、光栅化、合成这三步是在⾮主渲染线程执⾏\n重排、重绘、合成：开发中尽量减少重排重绘\n重排：改变了 DOM 元素的⼏何位置属性，⽐如宽度、⾼度，那么就会触发重新布局（Layout 阶段），及之后的⼦阶段；重排需要更新完整的流⽔线，开销也⽐较⼤\n重绘：通过CSS 或 JS 改变了⾮ DOM 元素的⼏何位置属性，⽐如背景⾊、边框⾊等；那么会跳过布局、分层阶段，直接到绘制阶段，执⾏效率⽐重排⾼⼀些\n合成：CSS3 动画，⽐如transform，直接在合成线程上合成动画操作，效率⽐较⾼\n\n\n\n\n\n\n连接结束关闭TCP链接（四次挥手）\n第一次挥手是浏览器发完数据后，发送FIN请求断开连接，进入FIN_WAIT_1状态\n第二次挥手是服务器收到FIN报文，返回ACK报文段表示同意，进入FIN_WAIT_2状态\n第三次挥手是服务器发送FIN报文请求关闭连接，进入LAST_ACK状态\n第四次挥手是浏览器收到FIN报文段，向服务器发送ACK报文段，进入TIME_WAIT状态。服务器接收到ACK报文关闭连接，浏览器等待一段时间后，表示服务器已关闭连接，也关闭连接。\n\n\n\n2、性能检测工具原理：就是在合适的时机，打上合适的时间戳，或者暴露出事件。然后通过这些时间戳之间的差值，得出⼀个耗时时间。这个耗时时间就可以反映出我们⻚⾯的相关性能。工具如下：\n\nwindow全局作用域API：performance\n性能检测对象：PerformanceObserver.observe()\n前端框架：web-vitals\n\n1、performancePerformance接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API\n\nUser Timing API ：⽤户⾃⼰定义在代码中通过调⽤ performance.mark（key） ⽅法定义的时间点。\nNavigation Timing API ： 资源请求的时间戳，它⾥⾯包含的是我们从请求开始到整个⻚⾯的完全显示的各个阶段的时间点，具体时间点如下：\n\n\n\n\n\n\nkey值\nvalue值解释\n\n\n\n\nnavigationStart\n当前浏览器窗⼝的前⼀个⽹⻚关闭，发⽣unload事件时的时间戳。如果没有前⼀个⽹⻚，就等于fetchStart（也就是输⼊URL开始，第⼀步就是卸载上个⻚⾯）\n\n\n\nredirectStart\n第⼀次重定向开始时的时间戳，如果没有重定向，或者上次重定向不是同源的，则为0\n\n\n\nredirectEnd\n最后⼀次重定向完成，也就是Http响应的最后⼀个字节返回时的时间戳，如果没有重定向，或者上次重定向不是同源的，则为0\n\n\n\nfetchStart\n浏览器准备通过HTTP请求去获取⻚⾯的时间戳。在检查应⽤缓存之前发生\n\n\n\ndomainLookupStart\n域名查询开始时的时间戳。如果使⽤持久连接，或者从本地缓存获取信息的，等同于fetchStart\n\n\n\ndomainLookupEnd\n域名查询结束时的时间戳。如果使⽤持久连接，或者从本地缓存获取信息的，等同于fetchStart\n\n\n\nconnectStart\nHTTP请求开始向服务器发送时的时间戳，如果是持久连接，则等同于fetchStart\n\n\n\nconnectEnd\n浏览器与服务器之间的连接建⽴时的时间戳，连接建⽴指的是所有握⼿和认证过程全部结束\n\n\n\nrequestStart\n浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳\n\n\n\nresponseEnd\n浏览器从服务器收到（或从本地缓存读取）最后⼀个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的时间戳\n\n\n\ndomLoading\n当前⽹⻚DOM结构开始解析时，也就是document.readyState属性变为“loading”、并且相应的readystatechange事件触发时的时间戳\n\n\n\ndomInteractive\n当前⽹⻚DOM结构结束解析\n\n\n\ndomContentLoadedEventStart\n当前⽹⻚DOMContentLoaded事件发⽣时，也就是DOM结构解析完毕、所有脚本开始运⾏时的时间戳\n\n\n\ndomContentLoadedEventEnd\n当前⽹⻚DOMContentLoaded事件发⽣时，也就是DOM结构解析完毕、所有脚本运⾏完成时的时间戳\n\n\n\ndomComplete\n当前⽹⻚DOM结构⽣成时，也就是Document.readyState属性变为“complete”\n\n\n\nloadEventStart\n当前⽹⻚load事件的回调函数开始时的时间戳。如果该事件还没有发⽣，返回0\n\n\n\nloadEventEnd\n当前⽹⻚load事件的回调函数结束时的时间戳。如果该事件还没有发⽣，返回0\n\n\n&#x2F;&#x2F;window.performance\n&#123;\n  Performance: &#123;\n    eventCounts: EventCounts &#123;size: 36&#125;,\n    memory: MemoryInfo &#123;totalJSHeapSize: 14794652, usedJSHeapSize: 12567868, jsHeapSizeLimit: 2172649472&#125;,\n    navigation: PerformanceNavigation &#123;type: 0, redirectCount: 0&#125;,\n    onresourcetimingbufferfull: null,\n    timeOrigin: 1630237780077,\n    timing: PerformanceTiming &#123;\n      connectEnd: 1630237780080\n      connectStart: 1630237780080\n      domComplete: 1630237780410\n      domContentLoadedEventEnd: 1630237780355\n      domContentLoadedEventStart: 1630237780351\n      domInteractive: 1630237780351\n      domLoading: 1630237780126\n      domainLookupEnd: 1630237780080\n      domainLookupStart: 1630237780080\n      fetchStart: 1630237780080\n      loadEventEnd: 1630237780410\n      loadEventStart: 1630237780410\n      navigationStart: 1630237780077\n      redirectEnd: 0\n      redirectStart: 0\n      requestStart: 1630237780081\n      responseEnd: 1630237780083\n      responseStart: 1630237780081\n      secureConnectionStart: 0\n      unloadEventEnd: 0\n      unloadEventStart: 0\n      [[Prototype]]: PerformanceTiming\n  &#125;\n    [[Prototype]]: Performance,\n  &#125;\n&#125;\n\n\n2、performanceObserverPerformanceObserver.observe() ：指定监测的 entry types 的集合。 当 performance entry 被记录并且是指定的 entryTypes 之⼀的时候，性能观察者对象的回调函数会被调⽤。\nvar observer &#x3D; new PerformanceObserver(callback);\n&#x2F;&#x2F;首个参数是性能观察者参数列表、第二个参数是观察者对象\nvar observer &#x3D; new PerformanceObserver(function(list, obj) &#123;\n  var entries &#x3D; list.getEntries();\n  for (var i&#x3D;0; i &lt; entries.length; i++) &#123;\n    &#x2F;&#x2F; Process &quot;mark&quot; and &quot;frame&quot; events\n  &#125;\n&#125;);\n&#x2F;&#x2F;当记录一个指定类型的性能条目时，性能监测对象的回调函数将会被调用。\nobserver.observe(&#123;entryTypes: [&quot;mark&quot;, &quot;frame&quot;]&#125;);\n\n3、web-vitals前端框架，⽬前只能统计’CLS‘ | ‘FCP‘ | ‘FID‘ | ‘LCP‘ | ‘TTFB‘。如果需要扩充的话，就可以使⽤上⾯的Performance 进⾏更改\nimport &#123;getCLS, getFID, getLCP&#125; from &#39;web-vitals&#39;;\n\ngetCLS(console.log);\ngetFID(console.log);\ngetLCP(console.log);\n\n3、性能指标1、白屏时间FP输入URL开始，到页面开始有变化，只要有任意像素点的变化，就算是白屏时间完结\nfunction getFP() &#123;\n  new PerformanceObserver((entryList, observer) &#x3D;&gt; &#123;\n    let entries &#x3D; entryList.getEntries();\n    for (let i &#x3D; 0; i &lt; entries.length; i++) &#123;\n      if (entries[i].name &#x3D;&#x3D;&#x3D; &#39;first-paint&#39;) &#123;\n        console.log(&#39;FP&#39;, entries[i].startTime);\n      &#125;\n    &#125;\n  &#125;).observe(&#123;entryTypes: [&#39;paint&#39;]&#125;);\n&#125;;\n\n2、首次内容绘制时间FCP指的是⻚⾯上绘制了第⼀个元素的时间\nFP与FCP的最⼤的区别就在于：FP 指的是绘制像素，⽐如说⻚⾯的背景⾊是灰⾊的，那么在显示灰⾊背景时就记录下了 FP 指标。但是此时 DOM 内容还没开始绘制，可能需要⽂件下载、解析等过程，只有当 DOM 内容发⽣变化才会触发，⽐如说渲染出了⼀段⽂字，此时就会记录下 FCP 指标。因此说我们可以把这两个指标认为是和⽩屏时间相关的指标，所以肯定是最快越好。\nfunction getFP() &#123;\n  new PerformanceObserver((entryList, observer) &#x3D;&gt; &#123;\n    let entries &#x3D; entryList.getEntries();\n    for (let i &#x3D; 0; i &lt; entries.length; i++) &#123;\n      if (entries[i].name &#x3D;&#x3D;&#x3D; &#39;first-contentful-paint&#39;) &#123;\n        console.log(&#39;FCP&#39;, entries[i].startTime);\n      &#125;\n    &#125;\n  &#125;).observe(&#123;entryTypes: [&#39;paint&#39;]&#125;);\n&#125;;\n\n3、首页时间FIRSTPAGE当onload事件触发的时候，也就是整个⾸⻚加载完成的时候\nfunction getFirstPage() &#123;\n  console.log(&#39;FIRSTPAGE&#39;, (performance.timing.loadEventEnd - performance.timing.fetchStart));\n&#125;;\n\n4、最大内容绘制LCP⽤于记录视窗内最⼤的元素绘制的时间，该时间会随着⻚⾯渲染变化⽽变化，因为⻚⾯中的最⼤元素在渲染过程中可能会发⽣改变，另外该指标会在⽤户第⼀次交互后停⽌记录。\nfunction getLCP() &#123;\n  new PerformanceObserver((entryList, observer) &#x3D;&gt; &#123;\n      let entries &#x3D; entryList.getEntries();\n      const lastEntry &#x3D; entries[entries.length - 1];\n      console.log(&#39;LCP&#39;, lastEntry.renderTime || lastEntry.loadTime);\n  &#125;).observe(&#123;entryTypes: [&#39;largest-contentful-paint&#39;]&#125;);\n&#125;\n\n5、首次可交互时间TTIFCP指标后，首个长任务执行时间点，其后无长任务或2个get请求。\n\n从 FCP 指标后开始计算\n持续 5 秒内⽆⻓任务（执⾏时间超过 50 ms）且⽆两个以上正在进⾏中的 GET 请求\n往前回溯⾄ 5 秒前的最后⼀个⻓任务结束的时间\n\n\nfunction getTTI() &#123;\n  let time &#x3D; performance.timing.domInteractive - performance.timing.fetchStart;\n  console.log(&#39;TTI&#39;, time);\n&#125;;\n\n6、网络请求耗时TTFB网络请求耗时(TTFB): responseStart - requestStart\n7、首次输入延迟FID从用户第一次与页面交互到浏览器实际能够开始处理事件的时间，在 FCP（首次内容绘制） 和 TTI （首次可交互时间）之间⽤户⾸次与⻚⾯交互时响应的延迟，eg：点击输入框后，因渲染等引起的延迟\nfunction getFID() &#123;\n  new PerformanceObserver((entryList, observer) &#x3D;&gt; &#123;\n    let firstInput &#x3D; entryList.getEntries()[0];\n    if (firstInput) &#123;\n        const FID &#x3D; firstInput.processingStart - firstInput.startTime;\n        console.log(&#39;FID&#39;, FID);\n    &#125;\n    &#125;).observe(&#123;type: &#39;first-input&#39;, buffered: true&#125;);\n &#125;\n\n8、累计位置偏移CLS⻚⾯渲染过程中突然插⼊⼀张巨⼤的图⽚或者说点击了某个按钮突然动态插⼊了⼀块内容等等相当影响⽤户体验的⽹站。这个指标就是为这种情况⽽⽣的，计算⽅式为：位移影响的⾯积 * 位移距离。如下图： 0.25 * 0.75 = 0.1875 。CLS 推荐值为低于 0.1\nfunction getCLS() &#123;\n  try &#123;\n    let cumulativeLayoutShiftScore &#x3D; 0;\n    const observer &#x3D; new PerformanceObserver((list) &#x3D;&gt; &#123;\n        for (const entry of list.getEntries()) &#123;\n            &#x2F;&#x2F; Only count layout shifts without recent user input.\n            if (!entry.hadRecentInput) &#123;\n                cumulativeLayoutShiftScore +&#x3D; entry.value;\n            &#125;\n        &#125;\n    &#125;);\n    observer.observe(&#123;type: &#39;layout-shift&#39;, buffered: true&#125;);\n    document.addEventListener(&#39;visibilitychange&#39;, () &#x3D;&gt; &#123;\n        if (document.visibilityState &#x3D;&#x3D;&#x3D; &#39;hidden&#39;) &#123;\n              &#x2F;&#x2F; Force any pending records to be dispatched.\n              observer.takeRecords();\n              observer.disconnect();\n              console.log(&#39;CLS:&#39;, cumulativeLayoutShiftScore);\n        &#125;\n    &#125;);\n  &#125; catch (e) &#123;\n      &#x2F;&#x2F; Do nothing if the browser doesn&#39;t support this API.\n  &#125;\n&#125;;\n\n9、使用方法\n问题：这几个指标怎么使用\nvue：定义公用方法类，common.js，mounted阶段页面进行挂载，$nextTick()里对响应方法进行使用\nreact：hooks useEffect()中使用react useEffect(() =&gt; {}, []);\n公司内部使用打点系统：使用echars绘制，使用均值统计、百分位数统计、样本分布统计输出性能\n自己使用：使用谷歌lighthouse插件检查性能\n\n\n⾕歌的标准，关注：LCP（最大内容绘制时间）、FID（首次输入延迟）、CIS（累计位移偏移）\n\n\n\nGood\nPoor\nPercentile\n\n\n\nLargest Contentful Paint\n&lt;=2500ms\n&gt;4000ms\n75\n\n\nFirst Input Delay\n&lt;=100ms\n&gt;300ms\n75\n\n\nCumulative Layout Shift\n&lt;=0.1\n&gt;0.25\n75\n\n\n\n\n\nLCP 代表了页面的速度指标，虽然还存在其他的一些体现速度的指标。一是指标实时更新，数据更精确，二是代表着页面最大元素的渲染时间，通常来说页面中最大元素的快速载入能让用户感觉性能还挺好。\nFID 代表了页面的交互体验指标，毕竟没有一个用户希望触发交互以后页面的反馈很迟缓，交互响应的快会让用户觉得网页挺流畅。\nCLS 代表了页面的稳定指标，尤其在手机上这个指标更为重要。因为手机屏幕挺小，CLS 值一大的话会让用户觉得页面体验做的很差。\n\n4、优化方法1、LCP1、影响元素影响白屏时间，相关因素如下：\n\nbody前是否存在阻塞的script标签，以及是否存在⻓时间执⾏的任务，即JS包⼤⼩问题以及是否启⽤了JS异步加载。\n⽹速问题\n\n2、提升方法\n提⾼带宽（⽹速）\n需要使⽤webpack进⾏tree-shaking\n使⽤路由懒加载，只有在使⽤的时候在进⾏路由加载\n部署CDN，缩短⽤户与节点之间的距离（⽹速）\n建⽴缓存，提⾼下次加载速度。\n开启gzip压缩。\n不要在头部添加任何script标签，或使用js异步加载defer。\n对于少量⼩图标（单个尽量不要超过10K的），我们可以使⽤url-loader打包。或者使⽤将图标转化为字体库，异步进⾏加载。\n对于⼤图标的话，需要做到在展示的时候再去加载。也就是当图⽚出现到浏览器窗⼝的时候再去加载，⽽不是⾸屏的图⽚全部加载。\n\n2、CIS1、提升方法\n如果经常需要变动的元素，脱离⽂档流，或者是占据位置，只是隐藏。\n对于位移等操作，使⽤动画代替，使⽤transform\n在定义图⽚的时候，就应该给出具体的宽⾼。\n\n3、FID对于⽤户可操作时间，影响⼀个是注册的事件是否可以被执⾏（说的通俗点就是JS脚本是否加载完毕），以及是否存在⻓任务。那么我们就可以有以下解决⽅案：\n\n对⽂件进⾏懒加载，不要⼀次性把所有的JS加载出来。这就需要使⽤路由懒加载，在跳转到某个路由的时候，再去加载他的脚本资源。这样就可以保证JS加载速度的优化。\n不要在响应事件⾥有过多的运算，导致卡顿。如果确有需要，应当开启webWorker，新起线程运算。\n\n4、bigpipe框架bigPipe是由facebook提出来的⼀种动态⽹⻚加载技术。它将⽹⻚分解成称为pagelets的⼩块，然后分块传输到浏览器端，进⾏渲染。它可以有效地提升⾸屏渲染时间。bigpipe的适⽤是服务端进⾏渲染，然后将⼀块⼀块的⽂件传递给前端。\n\n\n\n\n\n\n\n\n\nTIP面试：做了哪些性能相关的工作？如何统计性能、发现问题、处理问题、提升效果\n5、实战整体优化思路及解析：\n\n从浏览器输入url到页面各阶段做了什么，进行性能优化\n根据前端性能指标进行优化\n框架特有的性能优化点：小程序分包、vue路由按需加载等\n优化方法：开发规范、技术架构设计、系统架构设计\n\n1、浏览器加载优化\nDNS预解析、预链接&lt;!-- 开启隐式预解析：默认情况，浏览器对a标签中与当前域名不在同一域的相关域名进行预获取且缓存结果，对于https失效 --&gt;\n&lt;meta http-equiv&#x3D;&quot;x-dns-prefetch-control&quot; content&#x3D;&quot;on&quot;&gt;\n&lt;!-- 只解析域名，不进行资源下载 --&gt;\n&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot; &#x2F;&gt;\n&lt;!-- 将会做 DNS 解析，TLS 协商和 TCP 握手 --&gt;\n&lt;link  rel&#x3D;&quot;preconnect&quot; href&#x3D;&quot;&#x2F;&#x2F;baidu.com&quot;&gt;\nhttp请求阶段\n减少http请求合理利用时序：资源合并（雪碧图）、使用promise.all并发请求\n减少资源体积：减少cookie信息、图片格式优化、gzip静态资源压缩、webpack打包压缩\n合理利用缓存：cdn、http缓存（强缓存和协商缓存）、本地缓存（localStorage、sessionStorage）\n\n\n浏览器渲染阶段：下载css并解析、下载js文件并解析会影响页面首屏渲染\n减少重排重绘，尽量使用css动画，或者添加will-change属性\nscript脚本放在body元素中⻚⾯内容的后⾯，避免JS阻碍html解析，减少⽩屏时间\ncss文件尽量放在head中，尽快下载和解析\n使用预解析和异步加载：prefetch、prerender、preload、async、defer\n服务器端渲染ssr\n资源按需引入：路由懒加载，组件库按需引入&lt;!-- 在浏览器空闲时下载资源 --&gt;\n&lt;link rel&#x3D;&quot;prefetch&quot; href&#x3D;&quot;https:&#x2F;&#x2F;css-tricks.com&#x2F;a.png&quot;&gt;\n&lt;!-- 浏览器会提前完成所有的资源加载，执行，渲染并保存在内存里 --&gt;\n&lt;link rel&#x3D;&quot;prerender&quot; href&#x3D;&quot;https:&#x2F;&#x2F;css-tricks.com&quot;&gt;\n&lt;!-- 提前下载资源，影响资源加载顺序，后置下载资源前置下载 --&gt;\n&lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;https:&#x2F;&#x2F;fonts.gstatic.com&#x2F;s&#x2F;sofia&#x2F;v8&#x2F;bjl.woff2&quot; as&#x3D;&quot;font&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt;\n\n&lt;!-- ⽂件加载完成后，会执⾏此脚本，执⾏顺序⽆法保证，先加载完成的先执⾏ --&gt;\n&lt;script src&#x3D;&quot;.&#x2F;static&#x2F;demo1.js&quot; async&gt;&lt;&#x2F;script&gt;\n&lt;!-- 延迟执⾏脚本，解析完&lt;&#x2F;html&gt;后执⾏，执⾏顺序不变 --&gt;\n&lt;script src&#x3D;&quot;.&#x2F;static&#x2F;defer-demo1.js&quot; defer&gt;&lt;&#x2F;script&gt;\n\n\n\n2、性能指标监测分析工具：lighthouse、web-vitals\n底层api：performance\n指标解析：\n\nFP 首次绘制（白屏时间）、LCP 最大内容渲染：路由懒加载、缓存、脚本异步加载\n\nTTI首次可交互时间：performance.timing.domInteractive -performance.timing.fetchStart\n\nFID首次输入延迟：路由懒加载、建少js计算逻辑\n\nCIS累计位置偏移：css动画设置位移、图片设置具体宽高\n\n\n3、优化方法1、开发规范\ncss开发规范：雪碧图、图片格式优化、尽量减少重排和重绘，使用动画\njs开发规范：promise并发、预解析和懒加载、开发细节（for循环缓存对象、尽量少使用闭包、递归的边界条件）\n\n2、技术框架\n路由懒加载\n组件按需引入：babel插件转换\nwebpack打包优化配置：资源压缩、资源拆分部署至cdn（externals）\n小程序：分包加载、setData操作优化、限频接口调用优化等\n\n3、架构优化\ncdn预热\nnginx缓存配置、gzip压缩开启\nssr及预渲染\n后端bigpipe引入：动态网页加载技术\n\n","slug":"20220226-front-end-performance-optimization","date":"2022-02-26T06:00:00.000Z","categories_index":"前端优化","tags_index":"优化","author_index":"络擎"},{"id":"5b57e5b4a1488b082baaa9f5c5285d16","title":"JavaScript中命名约定的最佳实践","content":"前言在前端开发过程中，遵循标准的命名约定可以提高代码的可读性。下面就来看看 JavaScript 中命名约定的最佳实践。\n\n1. 变量的命名约定\n\n\n\n\n\n\n\n\nJavaScript 变量名称是区分大小写的，大写和小写字母是不同的。比如：\nlet DogName &#x3D; &#39;Scooby-Doo&#39;;\nlet dogName &#x3D; &#39;Droopy&#39;;\nlet DOGNAME &#x3D; &#39;Odie&#39;;\nconsole.log(DogName);   &#x2F;&#x2F; &quot;Scooby-Doo&quot;\nconsole.log(dogName);   &#x2F;&#x2F; &quot;Droopy&quot;\nconsole.log(DOGNAME);   &#x2F;&#x2F; &quot;Odie&quot;\n\n\n\n\n\n\n\n\n\n\n但是，最推荐的声明 JavaScript 变量的方法是使用驼峰式变量名。我们可以对JavaScript 所有类型的变量使用驼峰式命名约定，这样就不会相同命名的变量。\n&#x2F;&#x2F; bad\nlet dogname &#x3D; &#39;Droopy&#39;; \n&#x2F;&#x2F; bad\nlet dog_name &#x3D; &#39;Droopy&#39;; \n&#x2F;&#x2F; bad\nlet DOGNAME &#x3D; &#39;Droopy&#39;; \n&#x2F;&#x2F; bad\nlet DOG_NAME &#x3D; &#39;Droopy&#39;; \n&#x2F;&#x2F; good\nlet dogName &#x3D; &#39;Droopy&#39;;\n\n\n\n\n\n\n\n\n\n\n变量的名称应该是不言自明的，并描述了储存的值。例如，如果需要一个变量来储存狗的名字，应该使用 dogName 而不是 Name，因为 dogNam 更有意义：\n&#x2F;&#x2F; bad\nlet d &#x3D; &#39;Droopy&#39;;\n&#x2F;&#x2F; bad\nlet name &#x3D; &#39;Droopy&#39;;\n&#x2F;&#x2F; good\nlet dogName &#x3D; &#39;Droopy&#39;;\n\n2. 布尔值的命名约定\n\n\n\n\n\n\n\n\n当定义布尔类型的变量时，应该使用is或者has作为变量的前缀。例如，如果需要一个变量来检查狗是否有主人，应该使用 hasOwner 作为变量名：\n&#x2F;&#x2F; bad\nlet bark &#x3D; false;\n&#x2F;&#x2F; good\nlet isBark &#x3D; false;\n\n&#x2F;&#x2F; bad\nlet ideal &#x3D; true;\n&#x2F;&#x2F; good\nlet areIdeal &#x3D; true;\n\n&#x2F;&#x2F; bad\nlet owner &#x3D; true;\n&#x2F;&#x2F; good\nlet hasOwner &#x3D; true;\n\n3. 函数的命名约定\n\n\n\n\n\n\n\n\nJavaScript 中函数的名称也是区分大小写的。因为在声明函数时，推荐使用驼峰式方法来命名函数。除此之外，推荐使用描述性名词和动词来作为前缀。例如，如果声明一个函数来获取名称，则函数名字应该是 getName：\n&#x2F;&#x2F; bad\nfunction name(dogName, ownerName) &#123; \n  return &#39;$&#123;dogName&#125; $&#123;ownerName&#125;&#39;;\n&#125;\n\n&#x2F;&#x2F; good\nfunction getName(dogName, ownerName) &#123; \n  return &#39;$&#123;dogName&#125; $&#123;ownerName&#125;&#39;;\n&#125;\n\n4. 常量的命名约定\n\n\n\n\n\n\n\n\nJavaScript 中的常量和变量是一样的，都区分大小写，在定义常量时，推荐使用大写，因为它们是不变的变量。\nconst LEG &#x3D; 4;\nconst TAIL &#x3D; 1;\nconst MOVABLE &#x3D; LEG + TAIL;\n\n\n\n\n\n\n\n\n\n\n如果变量声明名称中包含多个单词，就应该使用 UPPER_SNAKE_CASE。\nconst DAYS_UNTIL_TOMORROW &#x3D; 1;\n\n5. 类的命名约定\n\n\n\n\n\n\n\n\nJavaScript 中类的命名约定规则与函数非常相似，推荐使用描述性的名称来描述类的功能。函数名和类名之间的主要区别在于类名要使用大写开头：\nclass DogCartoon &#123; \n  constructor(dogName, ownerName) &#123; \n    this.dogName &#x3D; dogName; \n    this.ownerName &#x3D; ownerName; \n  &#125;\n&#125;\n\nconst cartoon &#x3D; new DogCartoon(&#39;Scooby-Doo&#39;, &#39;Shaggy&#39;);\n\n6. 组件的命名规则\n\n\n\n\n\n\n\n\nJavaScript 组件广泛应用于React、Vue等前端框架中。组件的命名建议与类保持一致，使用开头大写的驼峰式命名法：\n&#x2F;&#x2F; bad\nfunction dogCartoon(roles) &#123; \n  return ( \n    &lt;div&gt; \n      &lt;span&gt; Dog Name: &#123; roles.dogName &#125; &lt;&#x2F;span&gt; \n      &lt;span&gt; Owner Name: &#123; roles.ownerName &#125; &lt;&#x2F;span&gt; \n    &lt;&#x2F;div&gt; \n  );\n&#125; \n\n&#x2F;&#x2F; good\nfunction DogCartoon(roles) &#123; \n  return ( \n    &lt;div&gt; \n      &lt;span&gt; Dog Name: &#123; roles.dogName &#125; &lt;&#x2F;span&gt; \n      &lt;span&gt; Owner Name: &#123; roles.ownerName &#125; &lt;&#x2F;span&gt; \n    &lt;&#x2F;div&gt; \n  );\n&#125;\n\n\n\n\n\n\n\n\n\n\n由于组件的命名开头字母是大写，因此在使用时，就很容易和HTML、属性值等区分开来：\n&lt;div&gt; \n  &lt;DogCartoon \n    roles&#x3D;&#123;&#123; dogName: &#39;Scooby-Doo&#39;, ownerName: &#39;Shaggy&#39; &#125;&#125; \n  &#x2F;&gt;\n&lt;&#x2F;div&gt;\n\n7. 方法的命名约定\n\n\n\n\n\n\n\n\n这里说的方法指的是类中方法，在 JavaScript 中，类的方法和函数的结构是非常类似的，因此，命名约定规则也是一样的。推荐需要使用驼峰式方法来声明 JavaScript 方法，并使用动词作为前缀，使方法名称更有意义：\nclass DogCartoon &#123;\n  constructor(dogName, ownerName) &#123; \n    this.dogName &#x3D; dogName; \n    this.ownerName &#x3D; ownerName; \n  &#125;\n\n  getName() &#123; \n    return &#39;$&#123;this.dogName&#125; $&#123;this.ownerName&#125;&#39;; \n  &#125;\n&#125;\n\nconst cartoon&#x3D; new DogCartoon(&#39;Scooby-Doo&#39;, &#39;Shaggy&#39;);\n\nconsole.log(cartoon.getName());   &#x2F;&#x2F; &quot;Scooby-Doo Shaggy&quot;\n\n8. 私有函数的命名约定\n\n\n\n\n\n\n\n\n下划线 (_) 在 MySQL 和 PHP 等语言中广泛用于定义变量、函数和方法。但在 JavaScript 中，下划线用于表示私有变量或函数。例如，有一个私有函数名 toonName，则可以通过添加下划线作为前缀 (_toonName) 来将其表示为私有函数。\nclass DogCartoon &#123; \n  constructor(dogName, ownerName) &#123; \n    this.dogName &#x3D; dogName; \n    this.ownerName &#x3D; ownerName; \n    this.name &#x3D; _toonName(dogName, ownerName); \n  &#125; \n  _toonName(dogName, ownerName) &#123; \n    return &#96;$&#123;dogName&#125; $&#123;ownerName&#125;&#96;; \n  &#125; \n&#125;\n\nconst cartoon &#x3D; new DodCartoon(&#39;Scooby-Doo&#39;, &#39;Shaggy&#39;); \n\n&#x2F;&#x2F; good\nconst name &#x3D; cartoon.name;\nconsole.log(name);   &#x2F;&#x2F; &quot;Scooby-Doo Shaggy&quot; \n\n&#x2F;&#x2F; bad\nname &#x3D;cartoon._toonName(cartoon.dogName, cartoon.ownerName);\nconsole.log(name);   &#x2F;&#x2F; &quot;Scooby-Doo Shaggy&quot;\n\n9. 全局变量的命名约定\n\n\n\n\n\n\n\n\n对于 JavaScript 全局变量，没有特定的命名标准。建议对可变全局变量使用驼峰式大小写的方式，对不可变全局对象使用大写。\n10. 文件名的命名约定\n\n\n\n\n\n\n\n\n大多数 Web 服务器（Apache、Unix）在处理文件时都区分大小写。例如，flower.jpg 和 Flower.jpg 是不一样的。但是，如果从不区分大小写的服务器切换到区分大小写的服务器，即使是一个小错误也可能导致网站崩溃。因此，尽管它们是支持区分大小写的，建议在所有服务器中还是使用小写来命名文件。\n\n","slug":"20220224-javascript-naming","date":"2022-02-24T10:00:00.000Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"络擎"},{"id":"cdaf5778a92658d6959a7b30d99c6bfc","title":"TypeScript进阶之路","content":"前言随着项目越来越大,市面上所使用的五花八门插件库也越来越多,随便一个项目都少说会1w+行代码以上,导致项目维护越来越差。尤其上在开发原生JavaScript的时候从中找Bug更是难如登天。TypeScript犹如the Saviour让更多开发者得心应手,也是现在开发大型工程化项目必不可缺少的一部分语言了…\n一、TypeScript 是什么?TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。下图显示了 TypeScript 与 ES5、ES2015 和 ES2016 之间的关系：\n1.1 TypeScript 与 JavaScript 的区别\n\n\n-\nTypeScript\nJavaScript\n\n\n\n1\nJavaScript 的超集用于解决大型项目的代码复杂性\n一种脚本语言，用于创建动态网页\n\n\n2\n可以在编译期间发现并纠正错误\n作为一种解释型语言，只能在运行时发现错误\n\n\n3\n强类型，支持静态和动态类型\n弱类型，没有静态类型选项\n\n\n4\n最终被编译成 JavaScript 代码，使浏览器可以理解\n可以直接在浏览器中使用\n\n\n5\n支持模块、泛型和接口\n不支持模块，泛型或接口\n\n\n6\n社区的支持仍在增长，而且还不是很大\n大量的社区支持以及大量文档和解决问题的支持\n\n\n1.2 获取 TypeScript\n\n\n\n\n\n\n\n\n命令行的 TypeScript 编译器可以使用 npm 包管理器来安装。\n#1.安装 TypeScript$ npm install -g typescript\n\n#2.验证 TypeScript$ tsc -v \n# Version 4.0.2\n\n#3.编译 TypeScript 文件$ tsc helloworld.ts\n# helloworld.ts &#x3D;&gt; helloworld.js\n\n当然，对刚入门 TypeScript 的小伙伴来说，也可以不用安装 typescript，而是直接使用线上的 TypeScript Playground来学习新的语法或新特性。通过配置 TS Config 的 Target，可以设置不同的编译目标，从而编译生成不同的目标代码。下图示例中所设置的编译目标是ES5：\n\n1.3 典型 TypeScript 工作流程\n如你所见，在上图中包含 3 个 ts 文件：a.ts、b.ts 和 c.ts。这些文件将被TypeScript编译器，根据配置的编译选项编译成 3 个 js 文件，即 a.js、b.js 和 c.js。对于大多数使用 TypeScript 开发的 Web 项目，我们还会对编译生成的 js 文件进行打包处理，然后在进行部署。\n1.4 TypeScript 初体验新建一个 hello.ts 文件，并输入以下内容：\nfunction greet(person: string) &#123;\n  return &#39;Hello, &#39; + person;\n&#125;\n \nconsole.log(greet(&quot;TypeScript&quot;));\n观察以上编译后的输出结果，我们发现 person 参数的类型信息在编译后被擦除了。TypeScript 只会在编译阶段对类型进行静态检查，如果发现有错误，编译时就会报错。而在运行时，编译生成的 JS 与普通的 JavaScript 文件一样，并不会进行类型检查。\n二、TypeScript 基础类型#2.1 Boolean 类型let isDone: boolean &#x3D; false;\n&#x2F;&#x2F; ES5：var isDone &#x3D; false;\n\n#2.2 Number 类型let count: number &#x3D; 10;\n&#x2F;&#x2F; ES5：var count &#x3D; 10;\n#2.3 String 类型let name: string &#x3D; &quot;semliker&quot;;\n&#x2F;&#x2F; ES5：var name &#x3D; &#39;semlinker&#39;;\n#2.4 Symbol 类型const sym &#x3D; Symbol();\nlet obj &#x3D; &#123;\n  [sym]: &quot;semlinker&quot;,\n&#125;;\nconsole.log(obj[sym]); &#x2F;&#x2F; semlinker \n#2.5 Array 类型let list: number[] &#x3D; [1, 2, 3];\n&#x2F;&#x2F; ES5：var list &#x3D; [1,2,3];\n \nlet list: Array&lt;number&gt; &#x3D; [1, 2, 3]; &#x2F;&#x2F; Array&lt;number&gt;泛型语法\n&#x2F;&#x2F; ES5：var list &#x3D; [1,2,3];\n#2.6 Enum 类型使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。\n\n\n\n\n\n\n\n\n\n1.数字枚举\nenum Direction &#123;\n  NORTH,\n  SOUTH,\n  EAST,\n  WEST,\n&#125;\n \nlet dir: Direction &#x3D; Direction.NORTH;\n\n\n\n\n\n\n\n\n\n\n2.字符串枚举在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。\nenum Direction &#123;\n  NORTH &#x3D; &quot;NORTH&quot;,\n  SOUTH &#x3D; &quot;SOUTH&quot;,\n  EAST &#x3D; &quot;EAST&quot;,\n  WEST &#x3D; &quot;WEST&quot;,\n&#125;\n以上代码对应的ES5代码如下：\n&quot;use strict&quot;;\nvar Direction;\n(function (Direction) &#123;\n    Direction[&quot;NORTH&quot;] &#x3D; &quot;NORTH&quot;;\n    Direction[&quot;SOUTH&quot;] &#x3D; &quot;SOUTH&quot;;\n    Direction[&quot;EAST&quot;] &#x3D; &quot;EAST&quot;;\n    Direction[&quot;WEST&quot;] &#x3D; &quot;WEST&quot;;\n&#125;)(Direction || (Direction &#x3D; &#123;&#125;));\n\n通过观察数字枚举和字符串枚举的编译结果，我们可以知道数字枚举除了支持 从成员名称到成员值 的普通映射之外，它还支持 从成员值到成员名称 的反向映射：\nenum Direction &#123;\n  NORTH,\n  SOUTH,\n  EAST,\n  WEST,\n&#125;\n \nlet dirName &#x3D; Direction[0]; &#x2F;&#x2F; NORTH\nlet dirVal &#x3D; Direction[&quot;NORTH&quot;]; &#x2F;&#x2F; 0\n\n\n另外，对于纯字符串枚举，我们不能省略任何初始化程序。而数字枚举如果没有显式设置值时，则会使用默认规则进行初始化。\n\n\n\n\n\n\n\n\n\n3.常量枚举除了数字枚举和字符串枚举之外，还有一种特殊的枚举 —— 常量枚举。它是使用 const 关键字修饰的枚举，常量枚举会使用内联语法，不会为枚举类型编译生成任何JavaScript。为了更好地理解这句话，我们来看一个具体的例子：\nconst enum Direction &#123;\n  NORTH,\n  SOUTH,\n  EAST,\n  WEST,\n&#125;\n \nlet dir: Direction &#x3D; Direction.NORTH;\n\n以上代码对应的ES5代码如下：\n&quot;use strict&quot;;\nvar dir &#x3D; 0 &#x2F;* NORTH *&#x2F;;\n\n\n\n\n\n\n\n\n\n\n4.异构枚举异构枚举的成员值是数字和字符串的混合：\nenum Enum &#123;\n  A,\n  B,\n  C &#x3D; &quot;C&quot;,\n  D &#x3D; &quot;D&quot;,\n  E &#x3D; 8,\n  F,\n&#125;\n\n以上代码对于的 ES5 代码如下：\n&quot;use strict&quot;;\nvar Enum;\n(function (Enum) &#123;\n    Enum[Enum[&quot;A&quot;] &#x3D; 0] &#x3D; &quot;A&quot;;\n    Enum[Enum[&quot;B&quot;] &#x3D; 1] &#x3D; &quot;B&quot;;\n    Enum[&quot;C&quot;] &#x3D; &quot;C&quot;;\n    Enum[&quot;D&quot;] &#x3D; &quot;D&quot;;\n    Enum[Enum[&quot;E&quot;] &#x3D; 8] &#x3D; &quot;E&quot;;\n    Enum[Enum[&quot;F&quot;] &#x3D; 9] &#x3D; &quot;F&quot;;\n&#125;)(Enum || (Enum &#x3D; &#123;&#125;));\n\n通过观察上述生成的 ES5 代码，我们可以发现数字枚举相对字符串枚举多了 “反向映射”：\nconsole.log(Enum.A) &#x2F;&#x2F;输出：0\nconsole.log(Enum[0]) &#x2F;&#x2F; 输出：A\n\n#2.7 Any 类型在TypeScript中，任何类型都可以被归为any类型。这让any类型成为了类型系统的顶级类型（也被称作全局超级类型）。\nlet notSure: any &#x3D; 666;\nnotSure &#x3D; &quot;semlinker&quot;;\nnotSure &#x3D; false;\n\nany类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由：TypeScript 允许我们对any类型的值执行任何操作，而无需事先执行任何形式的检查。比如：\nlet value: any;\n \nvalue.foo.bar; &#x2F;&#x2F; OK\nvalue.trim(); &#x2F;&#x2F; OK\nvalue(); &#x2F;&#x2F; OK\nnew value(); &#x2F;&#x2F; OK\nvalue[0][1]; &#x2F;&#x2F; OK\n在许多场景下，这太宽松了。使用 any 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 any 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 any 带来的问题，TypeScript 3.0 引入了 unknown`类型。\n#2.8 Unknown 类型就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any）。下面我们来看一下 unknown 类型的使用示例：\nlet value: unknown;\n \nvalue &#x3D; true; &#x2F;&#x2F; OK\nvalue &#x3D; 42; &#x2F;&#x2F; OK\nvalue &#x3D; &quot;Hello World&quot;; &#x2F;&#x2F; OK\nvalue &#x3D; []; &#x2F;&#x2F; OK\nvalue &#x3D; &#123;&#125;; &#x2F;&#x2F; OK\nvalue &#x3D; Math.random; &#x2F;&#x2F; OK\nvalue &#x3D; null; &#x2F;&#x2F; OK\nvalue &#x3D; undefined; &#x2F;&#x2F; OK\nvalue &#x3D; new TypeError(); &#x2F;&#x2F; OK\nvalue &#x3D; Symbol(&quot;type&quot;); &#x2F;&#x2F; OK\n\n\n对 value 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 unknown 的值赋值给其他类型的变量时会发生什么？\nlet value: unknown;\n \nlet value1: unknown &#x3D; value; &#x2F;&#x2F; OK\nlet value2: any &#x3D; value; &#x2F;&#x2F; OK\nlet value3: boolean &#x3D; value; &#x2F;&#x2F; Error\nlet value4: number &#x3D; value; &#x2F;&#x2F; Error\nlet value5: string &#x3D; value; &#x2F;&#x2F; Error\nlet value6: object &#x3D; value; &#x2F;&#x2F; Error\nlet value7: any[] &#x3D; value; &#x2F;&#x2F; Error\nlet value8: Function &#x3D; value; &#x2F;&#x2F; Error\n\nunknown类型只能被赋值给 any 类型和 unknown 类型本身。直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 unknown 类型的值。毕竟我们不知道变量 value 中存储了什么类型的值。现在让我们看看当我们尝试对类型为unknown的值执行操作时会发生什么。以下是我们在之前any章节看过的相同操作：\nlet value: unknown;\n \nvalue.foo.bar; &#x2F;&#x2F; Error\nvalue.trim(); &#x2F;&#x2F; Error\nvalue(); &#x2F;&#x2F; Error\nnew value(); &#x2F;&#x2F; Error\nvalue[0][1]; &#x2F;&#x2F; Error\n将 value变量类型设置为unknown后，这些操作都不再被认为是类型正确的。通过将 any 类型改变为unknown类型，我们已将允许所有更改的默认设置，更改为禁止任何更改。\n#2.9 Tuple 类型众所周知，数组一般由同种类型的值组成，但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组。元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须提供每个属性的值。为了更直观地理解元组的概念，我们来看一个具体的例子：\nlet tupleType: [string, boolean];\ntupleType &#x3D; [&quot;semlinker&quot;, true];\n在上面代码中，我们定义了一个名为tupleType的变量，它的类型是一个类型数组 [string, boolean]，然后我们按照正确的类型依次初始化tupleType变量。与数组一样，我们可以通过下标来访问元组中的元素：\nconsole.log(tupleType[0]); &#x2F;&#x2F; semlinker\nconsole.log(tupleType[1]); &#x2F;&#x2F; true\n在元组初始化的时候，如果出现类型不匹配的话，比如：\ntupleType &#x3D; [true, &quot;semlinker&quot;];\n\n此时，TypeScript 编译器会提示以下错误信息：\n[0]: Type &#39;true&#39; is not assignable to type &#39;string&#39;.\n[1]: Type &#39;string&#39; is not assignable to type &#39;boolean&#39;.\n\n很明显是因为类型不匹配导致的。在元组初始化的时候，我们还必须提供每个属性的值，不然也会出现错误，比如：\ntupleType &#x3D; [&quot;semlinker&quot;];\n\n此时，TypeScript编译器会提示以下错误信息：\nProperty &#39;1&#39; is missing in type &#39;[string]&#39; but required in type &#39;[string, boolean]&#39;.\n\n#2.10 Void 类型某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void：\n&#x2F;&#x2F; 声明函数返回值为void\nfunction warnUser(): void &#123;\n  console.log(&quot;This is my warning message&quot;);\n&#125;\n\n以上代码编译生成的 ES5 代码如下：\n&quot;use strict&quot;;\nfunction warnUser() &#123;\n  console.log(&quot;This is my warning message&quot;);\n&#125;\n\n需要注意的是，声明一个void类型的变量没有什么作用，因为在严格模式下，它的值只能为undefined：\nlet unusable: void &#x3D; undefined;\n#2.11 Null 和 Undefined 类型ypeScript 里，undefined 和 null 两者有各自的类型分别为 undefined 和 null。\nlet u: undefined &#x3D; undefined;\nlet n: null &#x3D; null;\n\n#2.12 object, Object 和 {} 类型\n\n\n\n\n\n\n\n\n1.object 类型object类型是：TypeScript2.2 引入的新类型，它用于表示非原始类型。\n&#x2F;&#x2F; node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts\ninterface ObjectConstructor &#123;\n  create(o: object | null): any;\n  &#x2F;&#x2F; ...\n&#125;\n \nconst proto &#x3D; &#123;&#125;;\n \nObject.create(proto);     &#x2F;&#x2F; OK\nObject.create(null);      &#x2F;&#x2F; OK\nObject.create(undefined); &#x2F;&#x2F; Error\nObject.create(1337);      &#x2F;&#x2F; Error\nObject.create(true);      &#x2F;&#x2F; Error\nObject.create(&quot;oops&quot;);    &#x2F;&#x2F; Error\n\n\n\n\n\n\n\n\n\n\n2.Object 类型Object 类型：它是所有 Object 类的实例的类型，它由以下两个接口来定义：\nObject 接口定义了 Object.prototype 原型对象上的属性；\n&#x2F;&#x2F; node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts\ninterface Object &#123;\n  constructor: Function;\n  toString(): string;\n  toLocaleString(): string;\n  valueOf(): Object;\n  hasOwnProperty(v: PropertyKey): boolean;\n  isPrototypeOf(v: Object): boolean;\n  propertyIsEnumerable(v: PropertyKey): boolean;\n&#125;\n\nObjectConstructor 接口定义了 Object 类的属性。\n&#x2F;&#x2F; node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts\ninterface ObjectConstructor &#123;\n  &#x2F;** Invocation via &#96;new&#96; *&#x2F;\n  new(value?: any): Object;\n  &#x2F;** Invocation via function calls *&#x2F;\n  (value?: any): any;\n  readonly prototype: Object;\n  getPrototypeOf(o: any): any;\n  &#x2F;&#x2F; ···\n&#125;\n \ndeclare var Object: ObjectConstructor;\n\nObject 类的所有实例都继承了 Object 接口中的所有属性。\n\n\n\n\n\n\n\n\n\n3.{} 类型{} 类型描述了一个没有成员的对象。当你试图访问这样一个对象的任意属性时，TypeScript 会产生一个编译时错误。\n&#x2F;&#x2F; Type &#123;&#125;\nconst obj &#x3D; &#123;&#125;;\n \n&#x2F;&#x2F; Error: Property &#39;prop&#39; does not exist on type &#39;&#123;&#125;&#39;.\nobj.prop &#x3D; &quot;semlinker&quot;;\n但是，你仍然可以使用在 Object 类型上定义的所有属性和方法，这些属性和方法可通过 JavaScript 的原型链隐式地使用：\n&#x2F;&#x2F; Type &#123;&#125;\nconst obj &#x3D; &#123;&#125;;\n \n&#x2F;&#x2F; &quot;[object Object]&quot;\nobj.toString();\n\n#2.13 Never 类型never 类型表示的是那些永不存在的值的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。\n&#x2F;&#x2F; 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never &#123;\n  throw new Error(message);\n&#125;\n \nfunction infiniteLoop(): never &#123;\n  while (true) &#123;&#125;\n&#125;\n在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下：\ntype Foo &#x3D; string | number;\n \nfunction controlFlowAnalysisWithNever(foo: Foo) &#123;\n  if (typeof foo &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n    &#x2F;&#x2F; 这里 foo 被收窄为 string 类型\n  &#125; else if (typeof foo &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;\n    &#x2F;&#x2F; 这里 foo 被收窄为 number 类型\n  &#125; else &#123;\n    &#x2F;&#x2F; foo 在这里是 never\n    const check: never &#x3D; foo;\n  &#125;\n&#125;\n注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：\ntype Foo &#x3D; string | number | boolean;\n\n然而他忘记同时修改controlFlowAnalysisWithNever方法中的控制流程，这时候else分支的foo类型会被收窄为boolean类型，导致无法赋值给 never类型，这时就会产生一个编译错误。通过这个方式，我们可以确保controlFlowAnalysisWithNever 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：使用never避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。\n","slug":"20220218-typescript-advanced","date":"2022-02-18T06:00:00.000Z","categories_index":"TypeScript","tags_index":"typeScript","author_index":"络擎"},{"id":"4f44e49e46f2e8d19fd85ff6cfc31792","title":"Css实现网页png/svg等透明图片实时变色功能","content":"前言工作中经常会用到各种图标，我们会要求设计师ued同学放到iconfont中，但是有时候iconfont要求比较高，png或者svg图片没有问题，上传到iconfont中有时候会出现异常情况，ued同学很苦恼。iconfont的好处就是可以实时修改图标的颜色。一个图标，多处使用。那么png和svg图片能否达到iconfont的效果呢？可以随时修改png或者svg等图片图标的颜色呢？答案是有的，今天就给大家介绍一下，png或者svg如何更换颜色。\n使用mask遮罩实现png等图标更换颜色代码如下：\n&lt;span class&#x3D;&quot;changecolor&quot;&gt;&lt;&#x2F;span&gt;\n\n.changecolor &#123;\n  display: inline-block;\n  width: 432px; height: 99px;\n  background-color: #dd1b14;\n  -webkit-mask:url(.&#x2F;test.png) no-repeat;\n  mask:url(.&#x2F;test.png) no-repeat;\n  -webkit-mask-size: 100% 100%;\n  mask-size: 100% 100%;\n&#125;\n\n备注，本地直接html演示会提示跨域等问题，建议在localhost服务下面运行，本地可以把png转为base64来使用。\nCSS mask遮罩介绍CSS mask属性在使用的时候就是mask: xxx，但是现在随着这个属性的规范化，mask属性实际上已经成为了诸多mask-*的缩写，这和background, border性质是一样的。具体是哪些属性的缩写呢，可以参见下面的列表：\nmask-image\nmask-mode\nmask-repeat\nmask-position\nmask-clip\nmask-origin\nmask-size\nmask-type\nmask-composite\n我们写\nmask: url(.&#x2F;haorooms.svg) no-repeat center &#x2F; 100%; \n实际就是 mask-image mask-repeat mask-position 的缩写。\n\n\n\n\n\n\n\n\n\nmask-image\nmask-image 的作用就是用这个图片的不透明部分镂空显示底部的颜色。\n\n\n\n\n\n\n\n\n\nmask-mode\nmask-mode属性的默认值是match-source，意思是根据资源的类型自动采用合适的遮罩模式。\n例如，如果我们的遮罩使用的是SVG中的&lt; defs &gt;中的&lt; mask &gt;元素，则此时的mask-mode属性的计算值是luminance，表示基于亮度遮罩。如果是其他场景，则计算值是alpha，表示基于透明度遮罩。\n因此，mask-mode支持下面3个属性值：\nmask-mode: alpha;此关键字指示应使用掩码层图像的透明度（阿尔法通道）值作为掩码值。\nmask-mode: luminance;此关键字指示掩膜层图像的亮度值应用作掩码值。\nmask-mode: match-source;（默认值）根据资源的类型自动采用合适的遮罩模式。\n\n\n\n\n\n\n\n\n\n\nmask-repeat，mask-position，mask-clip，mask-origin， mask-size\n这些属性基本和background一样，可以对比记忆。\n\n\n\n\n\n\n\n\n\nmask-type属性\nmask-type属性功能上和mask-mode类似，都是设置不同的遮罩模式。但还是有个很大的区别，那就是mask-type只能作用在SVG元素上，本质上是由SVG属性演变而来，因此，Chrome等浏览器都是支持的。但是mask-mode是一个针对所有元素的CSS3属性，Chrome等浏览器并不支持，目前仅Firefox浏览器支持。\n由于只能作用在SVG元素上，因此默认值表现为SVG元素默认遮罩模式，也就是默认值是luminance，亮度遮罩模式。如果需要支持透明度遮罩模式，可以这么设置：\nmask-type: alpha;\n\n\n\n\n\n\n\n\n\n\nmask-composite属性详细介绍\nmask-composite表示当同时使用多个图片进行遮罩时候的混合方式。支持属性值包括：\nadd;遮罩累加。\nsubtract;遮罩相减。也就是遮罩图片重合的地方不显示。意味着遮罩图片越多，遮罩区域越小。\nintersect;遮罩相交。也就是遮罩图片重合的地方才显示遮罩，。\nexclude;遮罩排除。也就是后面遮罩图片重合的地方排除，当作透明处理。","slug":"20211121-css-png-svg","date":"2021-11-21T08:00:00.000Z","categories_index":"Css","tags_index":"css","author_index":"络擎"},{"id":"049eb65b467c492de37ae20e8e6396aa","title":"药企云GIT使用规范 v2.0","content":"药企云GIT使用规范 v2.0\n\n\n\n\n\n\n\n\nGit usage standards version 2.0\n工具介绍-GitKrakenGitKraken是基于Git代码管理的一个UI管理器，拥有非常精美的界面，可以配合Gitlab、Github、Gitee来使用。\n\n\nGitKraken创建分支流程\n\n\n\n\n\n\n\n\n根据TAPD的迭代进行创建\n\n\n\n\n\n\n\n\n\n\n在master上创建分支（创建分支由组长创建）\n\n\n\n\n\n\n\n\n\n\n正常迭代创建（dev/对应的版本号+qa环境）例：dev/vCOA-qa4\n\n\n\n\n\n\n\n\n\n\n紧急迭代创建（feature/对应的版本号+qa环境+紧急需求ID号）例：feature/vCOA-qa4-1004332\n\n\n\n\n\n\n\n\n\n\n紧急需求ID号\n\n\n\n\n\n\n\n\n\n\n修复分支创建（hotfix/对应的功能名称）例：hotfix/order\n\nGitKraken合并分支流程\n\n\n\n\n\n\n\n\n根据目前的工作流程，dev，feature，hotfix，这三个版块的分支，会进行合并（合并流程一致）\n第一步、将当前开发分支合并到对应qa/xxx环境让测试进行测试（由开发者合并） 例：Merge dev/vCOA-qa4 into qa/qa4\n\n第二步、将当前开发分支合并到release环境（由对应的模块负责人合并）例：Merge dev/vCOA-qa4 into release\n\n第三步、将当前开发分支合并到master（由上线的负责人合并）例：Merge dev/vCOA-qa4 into master\n\nGitKraken注意事项\n\n\n\n\n\n\n\n\n开发分支不能合并开发分支，比如：dev/xxx不能与feature/xxx合并  qa环境不能合并其他分支，release环境不能合并其他分支.  所有的分支创建都是由master拉取.  遇到代码冲突的问题谨慎处理，避免造成代码丢失的问题.  如果没有把握处理请求对应的开发一起看或者找组长.\n","slug":"20210830-yqy-git-standard2.0","date":"2021-08-30T09:42:43.000Z","categories_index":"Git","tags_index":"git,gitkraken","author_index":"络擎"},{"id":"0c362deea0e7505e0e85786492df47ac","title":"Mac 破解GitKraken教程","content":"GitKraken是什么？\n\n\n\n\n\n\n\n\nGitKraken是基于Git代码管理的一个UI管理器，拥有非常精美的界面，可以配合Github、Gitee来使用。\n下载GitKraken我们选择在GitKraken官网安装最新版本的GitKraken，在官网安装的是收费的，不要管，先安装一遍并且登录一次 ps：一定要用收费版登录一次，可以免去以后使用破解版时每次打开都要登录 \n安装GitKraken下载完成后，即可得到一个installGitKraken.dmg文件，双击安装即可，安装完成之后，双击图标打开它。打开之后会出现7天试用期，需要在7天后进行收费，不用管它，打开过就可以关闭了。ps：如果以上步鄹都完成了，就可以跳过直接使用破解版的即可。Vue3\n使用破解版的GitKraken破解版的GitKraken，我存放在了百度网盘，大家直接下载即可版本是@7.0.0链接: https://pan.baidu.com/s/1VWWlRZNtKw_41x7x-L-k2A 提取码: giko下载完成之后，双击打开，里面有一个@7.0.0版本的GitKraken，把它拖动到mac访达里的应用程序，然后替换掉。\n 注：双击打开它的时候，会出现文件已损坏（这个时候别将它移到垃圾桶），执行后面的操作 \n“Mac应用”已损坏，打不开解决办法\n问题说明：通常在非 Mac App Store下载的软件都会提示“xxx已损坏，打不开。您应将它移到废纸篓”或者“打不开 xxx，因为它来自身份不明的开发者”。\n原因：Mac电脑启用了安全机制，默认只信任Mac App Store下载的软件以及拥有开发者 ID 签名的软件，但是同时也阻止了没有开发者签名的 “老实软件”\n解决方法：1.打开任何来源选项打开「终端.app」，输入以下命令并回车，输入开机密码回车\nsudo spctl --master-disable\n此行代码可以让 Mac 允许安装第三方来源的应用\n2.macOS Catalina 10.15系统：打开「终端.app」，输入以下命令并回车，输入开机密码回车\nsudo xattr -rd com.apple.quarantine 空格 软件的路径\n如Sketch.app\nsudo xattr -rd com.apple.quarantine &#x2F;Applications&#x2F;Sketch.app\n如CleanMyMac X.app\nsudo xattr -rd com.apple.quarantine &#x2F;Applications&#x2F;CleanMyMac X.app\n附1：/Applications/Sketch.app与/Applications/CleanMyMac X.app就是软件的路径附2：软件路径快速获取方法：将软件拖入「终端app」即可获得路径\n1\n\n3.macOS Catalina 10.15.4 系统：更新10.15.4系统后软件出现意外退出，可按照下面的方法给软件签名\n1.打开「终端app」输入如下命令：xcode-select --install\n2.给软件签名打开终端工具输入并执行如下命令：sudo codesign --force --deep --sign - (应用路径)\n注意：空格不能漏\n3.错误解决如出现以下错误提示： /文件位置 : replacing existing signature  /文件位置 : resource fork,Finder information,or similar detritus not allowed 那么，先在终端执行：xattr -cr &#x2F;文件位置（直接将应用拖进去即可）\n然后再次执行如下指令即可：codesign --force --deep --sign - &#x2F;文件位置（直接将应用拖进去即可）\n\n","slug":"20210827-mac-gitkraken-tutorial","date":"2021-08-27T07:08:00.000Z","categories_index":"Mac","tags_index":"gitkraken","author_index":"络擎"},{"id":"a89f699f60ab7f9698f8f81e34ce2863","title":"使用Console技巧提高JS调试效率","content":"其实 JavaScript 给到我们很多调试工具来调试代码，那问问你自己，你又知道多少呢？用到多少呢？\n大部分前端开发在 JavaScript 调试代码的常规用法都是直接console.log，直接输出某一个变量或者返回数据里面的对象数据。当然毋庸置疑这样输出来调试是没有问题的。但是不是最优雅的方式来调试代码，其实还有更好的办法。作为一个有追求的技术人才，有更好的调试方式为什么不去使用呢？\n我们先来了解清楚浏览器的console。浏览器的console对象有提供自带的调试控制台。console对象只能在浏览器的 JavaScript 中使用，也就是说客户端应用可用而服务端应用不可用。它的作用或者效果会根据不同的浏览器而不同，但是基础使用方式和功能是基本一致的。不过console是可以在任何前端语言或者框架中使用。\n\nconsole.log最常用的使用方式就是console.log，对前端开发工程师来说就是家常便饭了。以下是一个简单的使用例子。\nfunction sayHello(name) &#123;\n  console.log(name)\n&#125;\n\nsayHello(&#39;Indrek&#39;)\n\n\n\n\n\n\n\n\n\n\n以上sayHello方法接收一个名字，然后在控制台输出出来。\n\n现在我们开始玩以下更有趣的调试方法。加入我们现在想知道sayHello这个方法被调用了多少次，这样我们应该怎么调试呢？其实有一个很简单的办法就是使用console.count().\n\nconsole.countcount()方法会输出某一个标示被调用了几次。如果没有穿任何参数，count()默认为使用默认标示defaut。\nfunction sayHello(name) &#123;\n  console.count()\n  console.log(name)\n&#125;\n\nsayHello(&#39;Indrek&#39;)\nsayHello(&#39;William&#39;)\nsayHello(&#39;Kelly&#39;)\n\n\n\n\n\n\n\n\n\n\n以上代码就会在控制台输出以下结果：\n上面的例子实现了统计某一个方法被调用的次数，那如果我们想统计每个同名字(name)的在这个方法里面被调用了多少次呢？要调试这种其实也很简单，只要直接吧name直接传入count就可以了。\nfunction sayHello(name) &#123;\n  console.count(name)\n&#125;\n\nsayHello(&#39;Indrek&#39;)\nsayHello(&#39;William&#39;)\nsayHello(&#39;Kelly&#39;)\nsayHello(&#39;Indrek&#39;)\n‍(∩｀-´)⊃━☆ﾟ.*・｡ﾟ 巴拉巴拉！就是那么简单，我们就可以跟踪同名的参数在sayHello方法里面被调用的次数了！\n\n\nconsole.warn这个控台答应方法会输出一个警告信息。在你开发 APIs 或者开发工具的时候使用。console.warn这个方法在你需要警告用户的时候特别实用，例如漏掉了某个参数或者是让开发者知道你的 API/插件包的版本已经失效的时候使用。\nfunction sayHello(name) &#123;\n  if (!name) &#123;\n    console.warn(&#39;No name given&#39;)\n  &#125;\n&#125;\n\nsayHello()\n\n\n\n\n\n\n\n\n\n\n上面的代码检测了sayHello方法的参数是否漏传。如果name参数没有传，一个警告消息就会被打印到控制台中。让开发者可以思考问题出在哪里。\n\n\nconsole.table如果是我们在调试数组或者对象时，console.table是一个非常实用的调试方法来在控制台打印数据。数组里面的每一个元素都会在表格的行里面展示。以下是的水果名数组作为一个例子，如果我们把这个数组传入console.table，我们会看到一个含有这个水果名数据以表格的方式在控制台被打印出来。\nconst fruits &#x3D; [&#39;kiwi&#39;, &#39;banana&#39;, &#39;strawberry&#39;]\n\nconsole.table(fruits)\n\n\n\n\n\n\n\n\n\n\n我们一起来围观以下在控制台里面的展示效果\n\n看到了这个，你会不会灵光一闪想到 mmp，如果是一个很大的数组这种表格化的展示方式是多么的实用啊！对的！例如一个上百个数据的数组，我们使用这种调试方法来打印就很方便了。为了可以让我们用双眼见证这个说法的真实性，我们用代码说话吧！\nconst fruits &#x3D; [\n  &#39;Apple&#39;,\n  &#39;Watermelon&#39;,\n  &#39;Orange&#39;,\n  &#39;Pear&#39;,\n  &#39;Cherry&#39;,\n  &#39;Strawberry&#39;,\n  &#39;Nectarine&#39;,\n  &#39;Grape&#39;,\n  &#39;Mango&#39;,\n  &#39;Blueberry&#39;,\n  &#39;Pomegranate&#39;,\n  &#39;Carambola&#39;,\n  &#39;Plum&#39;,\n  &#39;Banana&#39;,\n  &#39;Raspberry&#39;,\n  &#39;Mandarin&#39;,\n  &#39;Jackfruit&#39;,\n  &#39;Papaya&#39;,\n  &#39;Kiwi&#39;,\n  &#39;Pineapple&#39;,\n  &#39;Lime&#39;,\n  &#39;Lemon&#39;,\n  &#39;Apricot&#39;,\n  &#39;Grapefruit&#39;,\n  &#39;Melon&#39;,\n  &#39;Coconut&#39;,\n  &#39;Avocado&#39;,\n  &#39;Peach&#39;,\n]\n我们使用console.table来打印一下上面这个大数组试试看吧。\n\n\n\n\n\n\n\n\n\n\n这种展示方式简直就是一目了然！这样妈妈再也不用担心我们调试数据的时候蒙圈了！՞༘✡ (๑ •̀ㅂ•́)و✧\n但是问题少年们，我们可是有梦想的工程师，如果是用来调试对象会是怎么样呢？来吧亲自动手丰衣足食，上代码！\nconst pets &#x3D; &#123;\n  name: &#39;Simon&#39;,\n  type: &#39;cat&#39;,\n&#125;\n\nconsole.table(pets)\n注意了兄弟姐妹们，现在我们打印的是对象不是数组。在控制台的表格现在有两个键值name和type。之前是 0，1，2，3，4…\n这种方式可以替代普遍使用的直接用 log 打印对象数据，表格化的展示相对还是更加清晰的。问题少年再次发问，如果我们想多个对象一起打印呢？\nconst pets &#x3D; &#123;\n  name: &#39;Simon&#39;,\n  type: &#39;cat&#39;,\n&#125;\n\nconst person &#x3D; &#123;\n  firstName: &#39;Indrek&#39;,\n  lastName: &#39;Lasn&#39;,\n&#125;\n\nconsole.table(pets, person)\n与预想一致，两个不同键值的对象被才分成两个表格在控制台打印出来了。\n如果我们不想分开两个表格打印，可否在一个表格显示呢？可以的！只要把两个对象放入一个数组就 ok 了。\nconst pets &#x3D; &#123;\n  name: &#39;Simon&#39;,\n  type: &#39;cat&#39;,\n&#125;\n\nconst person &#x3D; &#123;\n  firstName: &#39;Indrek&#39;,\n  lastName: &#39;Lasn&#39;,\n&#125;\n\nconsole.table([pets, person])\n现在我们看到两个对象在一个表格里面展示了，键值被放在表格的头部了，因为键值在两个对象里面是不一样的。\n\nconsole.group当我们是在调试集合（sets）或者是关联数据（linked-data），可以使用嵌套组来优化你的控制台输出。使用console.group()来创建一个嵌套的组。\nconsole.log(&#39;This is the first level&#39;)\nconsole.group()\nconsole.log(&#39;Level 2&#39;)\nconsole.group()\nconsole.log(&#39;Level 3&#39;)\nconsole.warn(&#39;More of level 3&#39;)\nconsole.groupEnd()\nconsole.log(&#39;Back to level 2&#39;)\nconsole.groupEnd()\nconsole.log(&#39;Back to the first level&#39;)\n以下是一个嵌套的层级提示输出，在调试关联或者层级数据的时候特别实用。\n\n\n\n\n\n\n\n\n\n使用console.groupCollapsed()可以把所有嵌套的层级收起来，使用鼠标点击时可以展开查看。\n\n总结作为一名优秀的程序员，我们应该尽量在合适的场景或者合适的情况下运用在提供到给我的调试工具。所以这一篇文章提到的调试方式，我们应该在开发调试的过程中多合理运用，习惯后我们会发现调试起来会更加敏捷和高效。\n\n\n\n\n\n\n\n\n\n\n#通过技术悟出人生道理# 💭“人生无常，写的了一行是一行Code now or never” ～ Hero络擎\n","slug":"20210801-console-js-debug","date":"2021-08-01T12:20:12.000Z","categories_index":"Console调试","tags_index":"console","author_index":"络擎"},{"id":"cefea648c41a530e5763e73f6b60f7e1","title":"Vue3.0初体验","content":"前言生命周期钩子\n我们可以直接看生命周期图来认识都有哪些生命周期钩子(图片是根据官网翻译后绘制的)：\n\n\n从图中我们可以看到Vue3.0新增了 setup ，这个在前面我们也详细说了， 然后是将Vue2.x中的 beforeDestroy 名称变更成 beforeUnmount; destroyed 表更为 unmounted ，作者说这么变更纯粹是为了更加语义化，因为一个组件是一个 mount 和 unmount 的过程。其他Vue2中的生命周期仍然保留。\n上边 生命周期图 中并没包含全部的生命周期钩子， 还有其他的几个， 全部生命周期钩子如图所示：我们可以看到 beforeCreate 和 created 被 setup 替换了（但是Vue3中你仍然可以使用， 因为Vue3是向下兼容的， 也就是你实际使用的是vue2的）。其次，钩子命名都增加了 ((on)) ; Vue3.x还新增用于调试的钩子函数 onRenderTriggered 和 onRenderTricked\n1.性能\n\n\n\n\n\n\n\n\n\n双向响应原理由Object.defineProperty改为基于ES6的Proxy，使其颗粒度更大，速度更快，且消除了之前存在的警告；\n重写了 Vdom ，突破了Vdom` 的性能瓶颈\n进行了模板编译的优化\n进行了更加高效的组件初始化\n\n2.Tree-Shaking 的支持支持了 tree-shaking （剪枝）：像修剪树叶一样把不需要的东西给修剪掉，使 Vue3 的体积更小。\n需要的模块才会打入到包里，优化后的 Vue3.0 的打包体积只有原来的一半（13kb）。哪怕把所有的功能都引入进来也只有23kb，依然比 Vue2.x 更小。像 keep-alive 、 transition 甚至 v-for 等功能都可以按需引入。\n3.Composition APIcomposition-api 是一个 Vue3 中新增的功能，它的灵感来自于 ReactHooks ，是比 mixin 更强大的存在。语法糖介绍\n\ncompositon-api提供了一下几个函数\n\n\n\n\n\n\n\n\n\n\n\nreactive\nwatchEffect\ncomputed\nref\ntoRefs\n\ncomposition-api 可以提高代码逻辑的可复用性，从而实现与模板的无关性；同时使代码的可压缩性更强。另外，把 Reactivity 模块独立开来，意味着 Vue3.0 的响应式模块可以与其他框架相组合。\n4.Fragments不再限制 template 只有一个根节点。render函数也可以返回数组了，有点像 React.Fragments\n5.Better TypeScript Support更好的类型推导，使得 *Vue3* 把 *TypeScript* 支持得非常好\n6.Custom Renderer API实现用*DOM*的方式进行 *WebGL* 编程\n\n体验Vue3.0初始化项目\n\n\n\n\n\n\n\n\n1. 使用脚手架创建项目\nvue create my-Project\n\n\n\n\n\n\n\n\n\n2. 安装composition-api，体验新特性\nnpm i @vue&#x2F;composition-api -s\n\n\n\n\n\n\n\n\n\n3. 使用插件\n&#x2F;&#x2F; main.js\n\nimport Vue from &#39;vue&#39;\nimport VueCompositionAPI from &#39;@vue&#x2F;composition-api&#39;\n\nVue.use(VueCompositionAPI)\n\nSetup函数setup() 函数是Vue3.0中，专门为组件提供的新属性。它为基于Composition API的新特性提供了统一的入口。\n在Vue3中，定义methods、watch、computed、data数据都放在了setup() 函数中\n\n\n\n\n\n\n\n\n\n1. 执行时机setup() 函数会在 created() 生命周期之前执行。\nsetup执行时机.png\n\n\n\n\n\n\n\n\n\n2. 接收props数据\nprops 是 setup() 函数的一个形参，组件接收的 props 数据可以在 setup() 函数内访问到。\nsetup(props) &#123;\n    console.log(props.p1)\n&#125;\n\n\n\n\n\n\n\n\n\n\n3. context上下文对象context 是 setup() 的第二个形参，它是一个上下文对象，可以通过 context 来访问Vue的实例 this。\nsetup(props,context) &#123;\n    console.log(this)\n    console.log(context)\n&#125;\n\n\n注意：在 setup() 函数中访问不到Vue的 this 实例\n\nTeleport如果用过React的同学，可能对于 Portals 比较熟悉，详见。React 的 Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案，我理解，Vue 3 中的 Teleport 跟这个其实是类似的\n在 Vue2，如果想要实现类似的功能，需要通过第三方库 portal-vue 去实现，感兴趣可以了解一下\n本篇文章主要来探讨以下两个点：\n\n\n\n\n\n\n\n\n\n\nTeleport是什么？它解决的是什么问题？\n通过一个小实例介绍Teleport的使用\n\n为什么我们需要 TeleportTeleport 是一种能够将我们的模板移动到DOM中Vue app之外的其他位置的技术，就有点像哆啦A梦的“任意门”\n场景：像modals,toast等这样的元素，很多情况下，我们将它完全的和我们的Vue 应用的 DOM`完全剥离，管理起来反而会方便容易很多\n原因在于如果我们嵌套在 Vue 的某个组件内部，那么处理嵌套组件的定位z-index和样式就会变得很困难\n另外，像modals,toast等这样的元素需要使用到Vue组件的状态（data 或者 props）的值\n这就是Teleport派上用场的地方。我们可以在组件的逻辑位置写模板代码，这意味着我们可以使用组件的 data 或 props。然后在 Vue 应用的范围之外渲染它Teleport的使用准备快速搭建一个vue3的项目\n$ npm init vite-app learn-vue3\n$ cd learn-vue3\n$ npm install\n$ npm run dev\n\n用yarn\n$ yarn create vite-app learn-vue3\n$ cd learn-vue3\n$ yarn\n$ yarn dev\n\n打开：http://localhost:3000/ ，看到如下页面，说明成功了\n\ntoastindex.html中\n&lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div id&#x3D;&quot;teleport-target&quot;&gt;&lt;&#x2F;div&gt;\n&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;&#x2F;src&#x2F;main.js&quot;&gt;&lt;&#x2F;script&gt;\n\nsrc/components/HelloWorld.vue中，添加如下，留意to属性跟上面的id选择器一致\n&lt;button @click&#x3D;&quot;showToast&quot; class&#x3D;&quot;btn&quot;&gt;打开 toast&lt;&#x2F;button&gt;\n&lt;!-- to 属性就是目标位置 --&gt;\n&lt;teleport to&#x3D;&quot;#teleport-target&quot;&gt;\n  &lt;div v-if&#x3D;&quot;visible&quot; class&#x3D;&quot;toast-wrap&quot;&gt;\n    &lt;div class&#x3D;&quot;toast-msg&quot;&gt;我是一个 Toast 文案&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;teleport&gt;\n\nimport &#123; ref &#125; from &#39;vue&#39;;\nexport default &#123;\n  setup() &#123;\n    &#x2F;&#x2F; toast 的封装\n    const visible &#x3D; ref(false);\n    let timer;\n    const showToast &#x3D; () &#x3D;&gt; &#123;\n      visible.value &#x3D; true;\n      clearTimeout(timer);\n      timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n        visible.value &#x3D; false;\n      &#125;, 2000);\n    &#125;\n    return &#123;\n      visible,\n      showToast\n    &#125;\n  &#125;\n&#125;\n\n可以看到，我们使用 teleport 组件，通过 to 属性，指定该组件渲染的位置与\n同级，也就是在 body 下，但是 teleport 的状态 visible 又是完全由内部Vue组件控制\n与 Vue components 一起使用 —— modal如果  包含 Vue 组件，则它仍将是 父组件的逻辑子组件\n接下来我们以一个 modal 组件为例\n&lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div id&#x3D;&quot;teleport-target&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div id&#x3D;&quot;modal-container&quot;&gt;&lt;&#x2F;div&gt;\n&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;&#x2F;src&#x2F;main.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;teleport to&#x3D;&quot;#modal-container&quot;&gt;\n  &lt;!-- use the modal component, pass in the prop --&gt;\n  &lt;modal :show&#x3D;&quot;showModal&quot; @close&#x3D;&quot;showModal &#x3D; false&quot;&gt;\n    &lt;template #header&gt;\n      &lt;h3&gt;custom header&lt;&#x2F;h3&gt;\n    &lt;&#x2F;template&gt;\n  &lt;&#x2F;modal&gt;\n&lt;&#x2F;teleport&gt;\nJS 核心代码如下：\nimport &#123; ref &#125; from &#39;vue&#39;;\nimport Modal from &#39;.&#x2F;Modal.vue&#39;;\nexport default &#123;\n  components: &#123;\n    Modal\n  &#125;,\n  setup() &#123;\n    &#x2F;&#x2F; modal 的封装\n    const showModal &#x3D; ref(false);\n    return &#123;\n      showModal\n    &#125;\n  &#125;\n&#125;\n在这种情况下，即使在不同的地方渲染Modal，它仍将是当前组件（调用 Modal 的组件）的子级，并将从中接收show prop\n这也意味着来自父组件的注入按预期工作，并且子组件将嵌套在 Vue Devtools 中的父组件之下，而不是放在实际内容移动到的位置\n看实际效果以及在Vue Devtool中。\n\n总结本文主要介绍了 Vue 3的新特性——Teleport，从为什么要使用Teleport，以及通过两个小 demo，演示它的基础使用，希望能够对你有帮助\n\nemits选项\n\n\n\n\n\n\n\n\n\n官方文档传送门\nVue官方建议我们在组件中所有的emit事件都能在组件的emits选项中声明\nemits参数有俩种形式对象和数组，对象里面可以配置带校验emit事件，为null的时候代表不校验，校验的时候，会把emit事件的参数传到校验函数的参数里面\n当校验函数不通过的时候，控制台会输出一个警告，但是emit事件会继续执行\n记录一个坑：比如你emit事件的名称正好和原生事件的名字重复了，那么这个事件会执行俩次，那么配置了emits这个选项的话，就能很好的解决这个问题，下去自己实验一下，这篇文章中不做演示\n我们看一下带校验和不带校验的emit事件一个例子\n\n子组件Emiter.vue\n&lt;template&gt;\n  &lt;button @click&#x3D;&quot;handleClick&quot;&gt;点击emit-click事件&lt;&#x2F;button&gt;\n  &lt;button @click&#x3D;&quot;handleOpen&quot;&gt;点击emit-open事件&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n&lt;script lang&#x3D;&quot;ts&quot;&gt;\nimport &#123;defineComponent&#125; from &quot;vue&quot;;\nexport default defineComponent(&#123;\n  emits: &#123;\n    click: null,&#x2F;&#x2F;click事件没有检验\n    open: (value) &#x3D;&gt; &#123;\n      if (typeof value &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n        return true;\n      &#125; else &#123;\n        return false;\n      &#125;\n    &#125;,\n  &#125;,\n  setup(props, &#123;emit&#125;) &#123;\n    const handleClick &#x3D; function() &#123;\n      emit(&quot;click&quot;);\n    &#125;;\n    const handleOpen &#x3D; function() &#123;\n      emit(&quot;open&quot;, 1);\n    &#125;;\n    return &#123;\n      handleClick,\n      handleOpen,\n    &#125;;\n  &#125;,\n  data() &#123;\n    return &#123;&#125;;\n  &#125;,\n  methods: &#123;&#125;,\n&#125;);\n&lt;&#x2F;script&gt;\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n父组件Emit.vue\n&lt;template&gt;\n  &lt;emiter @click&#x3D;&quot;onClick&quot; @open&#x3D;&quot;onOpen&quot;&gt;&lt;&#x2F;emiter&gt;\n&lt;&#x2F;template&gt;\n&lt;script lang&#x3D;&quot;ts&quot;&gt;\nimport &#123;defineComponent&#125; from &quot;vue&quot;;\nimport Emiter from &quot;@&#x2F;components&#x2F;Emiter.vue&quot;;\nexport default defineComponent(&#123;\n  components: &#123;\n    Emiter,\n  &#125;,\n  data() &#123;\n    return &#123;&#125;;\n  &#125;,\n  methods: &#123;\n    onClick() &#123;\n      console.log(&quot;click me!&quot;);\n    &#125;,\n    onOpen() &#123;\n      console.log(&quot;open me!&quot;);\n    &#125;,\n  &#125;,\n&#125;);\n&lt;&#x2F;script&gt;\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n看一下结果，控制台输出警告信息\n\n状态和事件绑定Vue 3.0 中定义状态的方法改为类似 React Hooks 的方法，下面我们在 Test.vue 中定义一个状态 count：\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;test&quot;&gt;\n    &lt;h1&gt;test count: &#123;&#123;count&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n \n&lt;script&gt;\n  import &#123; ref &#125; from &#39;vue&#39;\n \n  export default &#123;\n    setup () &#123;\n      const count &#x3D; ref(0)\n      return &#123;\n        count\n      &#125;\n    &#125;\n  &#125;\n&lt;&#x2F;script&gt;\n\nVue 3.0 中初始化状态通过setup方法，\n定义状态需要调用ref方法。接下来我们定义一个事件，用来更新count状态：\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;test&quot;&gt;\n    &lt;h1&gt;test count: &#123;&#123;count&#125;&#125;&lt;&#x2F;h1&gt;\n    &lt;button @click&#x3D;&quot;add&quot;&gt;add&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n \n&lt;script&gt;\n  import &#123; ref &#125; from &#39;vue&#39;\n \n  export default &#123;\n    setup () &#123;\n      const count &#x3D; ref(0)\n      const add &#x3D; () &#x3D;&gt; &#123;\n        count.value++\n      &#125;\n      return &#123;\n        count,\n        add\n      &#125;\n    &#125;\n  &#125;\n&lt;&#x2F;script&gt;\n\n这里的add方法不再需要定义在methods中，但注意更新count值的时候不能直接使用count++，而应使用 count.value++，更新代码后，点击按钮count的值就会更新了：\n\n计算属性和监听器Vue 3.0 中计算属性和监听器的实现依赖computed 和 watch方法：\ncomputed&lt;template&gt;\n  &lt;div class&#x3D;&quot;test&quot;&gt;\n    &lt;h1&gt;test count: &#123;&#123;count&#125;&#125;&lt;&#x2F;h1&gt;\n    &lt;div&gt;count * 2 &#x3D; &#123;&#123;doubleCount&#125;&#125;&lt;&#x2F;div&gt;\n    &lt;button @click&#x3D;&quot;add&quot;&gt;add&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n \n&lt;script&gt;\n  import &#123; ref, computed, watch &#125; from &#39;vue&#39;\n \n  export default &#123;\n    setup () &#123;\n      const count &#x3D; ref(0)\n      const add &#x3D; () &#x3D;&gt; &#123;\n        count.value++\n      &#125;\n      watch(() &#x3D;&gt; count.value, val &#x3D;&gt; &#123;\n        console.log(&#96;count is $&#123;val&#125;&#96;)\n      &#125;)\n      const doubleCount &#x3D; computed(() &#x3D;&gt; count.value * 2)\n      return &#123;\n        count,\n        doubleCount,\n        add\n      &#125;\n    &#125;\n  &#125;\n&lt;&#x2F;script&gt;\n计算属性computed是一个方法，里面需要包含一个回调函数，当我们访问计算属性返回结果时，会自动获取回调函数的值：\nconst doubleCount &#x3D; computed(() &#x3D;&gt; count.value * 2)\n\nwatch监听器watch同样是一个方法，它包含2个参数，2个参数都是 function：\nwatch(() &#x3D;&gt; count.value, \nval &#x3D;&gt; &#123;\n  console.log(&#96;count is $&#123;val&#125;&#96;)\n&#125;)\n第一个参数是监听的值，count.value表示当count.value发生变化就会触发监听器的回调函数，即第二个参数，第二个参数可以执行监听时候的回调如果是2个以上的监听属性 就这样\nwatch(\n  [refA, () &#x3D;&gt; refB.value],\n  ([a, b], [prevA, prevB]) &#x3D;&gt; &#123;\n    console.log(&#96;a is: $&#123;a&#125;&#96;)\n    console.log(&#96;b is: $&#123;b&#125;&#96;)\n  &#125;\n)\n\n\n持续更新，未完待续….\n\n","slug":"20210222-vue3.0-first-experience","date":"2021-02-22T07:00:00.000Z","categories_index":"Vue","tags_index":"vue","author_index":"络擎"},{"id":"57616fa894d45b50607a4eae43c9cf27","title":"前端技能训练-重构 v1.0","content":"或许你应该知道了，重构是怎样的，你也知道重构能带来什么。在我刚开始学重构和设计模式的时候，我需要去找一些好的示例，以便于我更好的学习。有时候不得不创造一些更好的场景，来实现这些功能。\n有一天，我发现当我需要我一次又一次地重复讲述某些内容，于是我就计划着把这些应该掌握的技能放到Github上，也就有了[Artisan Stack] 计划。\n每个程序员都不可避免地是一个Coder，一个没有掌握好技能的Coder，算不上是手工艺人，但是是手工人。\n艺，需要有创造性的方法。\n前端技能训练: 重构一为什么重构?\n\n\n\n\n\n\n\n\n为了更好的代码。\n在经历了一年多的工作之后，我平时的主要工作就是修Bug。刚开始的时候觉得无聊，后来才发现修Bug需要更好的技术。有时候你可能要面对着一坨一坨的代码，有时候你可能要花几天的时间去阅读代码。而，你重写那几十代码可能只会花上你不到一天的时间。但是如果你没办法理解当时为什么这么做，你的修改只会带来更多的bug。修Bug，更多的是维护代码。还是前人总结的那句话对:\n\n\n\n\n\n\n\n\n\n写代码容易，读代码难。\n假设我们写这些代码只要半天，而别人读起来要一天。为什么不试着用一天的时候去写这些代码，让别人花半天或者更少的时间来理解。\n如果你的代码已经上线，虽然是一坨坨的。但是不要轻易尝试，没有测试的重构。\n从前端开始的原因在于，写得一坨坨且最不容易测试的代码都在前端。\n让我们来看看我们的第一个训练，相当有挑战性。\n重构uMarkdown代码及setup请见github: [js-refactor]\n代码说明uMarkdown是一个用于将Markdown转化为HTML的库。代码看上去就像一个很典型的过程代码:\n/* code */\nwhile ((stra = micromarkdown.regexobject.code.exec(str)) !== null) &#123;\n  str = str.replace(stra[0], &#39;&lt;code&gt;\\n&#39; + micromarkdown.htmlEncode(stra[1]).replace(/\\n/gm, &#39;&lt;br/&gt;&#39;).replace(/\\ /gm, &#39;&amp;nbsp;&#39;) + &#39;&lt;/code&gt;\\n&#39;);\n&#125;\n\n/* headlines */\nwhile ((stra = micromarkdown.regexobject.headline.exec(str)) !== null) &#123;\n  count = stra[1].length;\n  str = str.replace(stra[0], &#39;&lt;h&#39; + count + &#39;&gt;&#39; + stra[2] + &#39;&lt;/h&#39; + count + &#39;&gt;&#39; + &#39;\\n&#39;);\n&#125;\n\n/* mail */\nwhile ((stra = micromarkdown.regexobject.mail.exec(str)) !== null) &#123;\n  str = str.replace(stra[0], &#39;&lt;a href=&quot;mailto:&#39; + stra[1] + &#39;&quot;&gt;&#39; + stra[1] + &#39;&lt;/a&gt;&#39;);\n&#125;\n\n选这个做重构的开始，不仅仅是因为之前在写[EchoesWorks]的时候进行了很多的重构。而且它更适合于，重构到设计模式的理论。让我们在重构完之后，给作者进行pull request吧。\nMarkdown的解析过程，有点类似于Pipe and Filters模式(架构模式)。\nFilter即我们在代码中看到的正规表达式集:\nregexobject: &#123;\n    headline: /^(\\#&#123;1,6&#125;)([^\\#\\n]+)$/m,\n    code: /\\s\\`\\`\\`\\n?([^`]+)\\`\\`\\`/g\n\n他会匹配对应的Markdown类型，随后进行替换和处理。而``str```，就是管理口的输入和输出。\n接着，我们就可以对其进行简单的重构。\n重构(ps: 推荐用WebStrom来做重构，自带重构功能)\n作为一个示例，我们先提出codeHandler方法，即将上面的\n/* code */\nwhile ((stra = micromarkdown.regexobject.code.exec(str)) !== null) &#123;\n  str = str.replace(stra[0], &#39;&lt;code&gt;\\n&#39; + micromarkdown.htmlEncode(stra[1]).replace(/\\n/gm, &#39;&lt;br/&gt;&#39;).replace(/\\ /gm, &#39;&amp;nbsp;&#39;) + &#39;&lt;/code&gt;\\n&#39;);\n&#125;\n\n提取方法成\ncodeFilter: function (str, stra) &#123;\n    return str.replace(stra[0], &#39;&lt;code&gt;\\n&#39; + micromarkdown.htmlEncode(stra[1]).replace(/\\n/gm, &#39;&lt;br/&gt;&#39;).replace(/\\ /gm, &#39;&amp;nbsp;&#39;) + &#39;&lt;/code&gt;\\n&#39;);\n  &#125;,\n\nwhile语句就成了\n  while ((stra = regexobject.code.exec(str)) !== null) &#123;\n        str = this.codeFilter(str, stra);\n    &#125;\n\n然后，运行所有的测试。\ngrunt test\n\n同理我们就可以mail、headline等方法进行重构。接着就会变成类似于下面的代码，\n  /* code */\n  while ((execStr = regExpObject.code.exec(str)) !== null) &#123;\n    str = codeHandler(str, execStr);\n  &#125;\n\n  /* headlines */\n  while ((execStr = regExpObject.headline.exec(str)) !== null) &#123;\n    str = headlineHandler(str, execStr);\n  &#125;\n\n  /* lists */\n  while ((execStr = regExpObject.lists.exec(str)) !== null) &#123;\n    str = listHandler(str, execStr);\n  &#125;\n\n  /* tables */\n  while ((execStr = regExpObject.tables.exec(str)) !== null) &#123;\n    str = tableHandler(str, execStr, strict);\n  &#125;\n\n然后你也看到了，上面有一堆重复的代码，接着让我们用JavaScript的奇技浮巧，即apply方法，把上面的重复代码变成。\n    [&#39;code&#39;, &#39;headline&#39;, &#39;lists&#39;, &#39;tables&#39;, &#39;links&#39;, &#39;mail&#39;, &#39;url&#39;, &#39;smlinks&#39;, &#39;hr&#39;].forEach(function (type) &#123;\n        while ((stra = regexobject[type].exec(str)) !== null) &#123;\n            str = that[(type + &#39;Handler&#39;)].apply(that, [stra, str, strict]);\n        &#125;\n    &#125;);\n\n进行测试，blabla，都是过的。\n Markdown\n   ✓ should parse h1~h3\n   ✓ should parse link\n   ✓ should special link\n   ✓ should parse font style\n   ✓ should parse code\n   ✓ should parse ul list\n   ✓ should parse ul table\n   ✓ should return correctly class name\n\n这样，我们就完成第一个重构训练了~~。\n","slug":"20200118-web-refactoring-1","date":"2020-01-18T05:08:43.000Z","categories_index":"重构","tags_index":"css,javaScript,html,vue.js","author_index":"络擎"},{"id":"521e38811c7e57bb1fda5cf202aa5848","title":"药企云GIT使用规范 v1.0","content":"药企云GIT使用规范 v1.0\n\n\n\n\n\n\n\n\nGit usage standards version 1.0\n介绍每一个优秀的开发团队都会用到一套代码管理工具。根据目前最流行的代码管理工具非GIT莫属。不例外药企云团队绝对使用最优秀的规范和工具。根据药企云项目的具体部署环境，开发规范，我们有一套自己的规范和标准的GIT使用方式。\n敏捷迭代如果要弄明白药企云的GIT使用，首先要了解清楚药企云项目的迭代流程\n\n什么是敏捷迭代？\n\n\n\n\n\n\n\n\n敏捷迭代就是把开发周期缩短到1-4周。小步快跑的迅速迭代交付功能上线。敏捷迭代的流程分别如下：\n\n确定需求 - 与老板和市场确认需求和流程\n需求评审 - 与开发同频需求里面的功能点和业务流程\n技术反讲 - 开发与产品同频需求，保证理解没有误区，开发也需要评估开发难度，和开发时间\n研发周期 - 开发人员开始投入研发直接到功能和需求开发完毕，转交给测试，在测试环境提测\n测试周期 - 测试和开发人员开始排除困难，修复所有在开发过程产生的bug\n验收/预发布周期 - 当测试在测试环境把所有bug排除掉后，当前迭代版本就会发布到预发布环境让市场和产品验收功能\n发布正式 - 当验收通过后，当前迭代版本就可以部署上先到正式环境\n正式回归测试 - 发布上线后，就会有正式回归测试，最有一道防线，保证系统加入了所有新功能都没有问题\n迭代总结 - 每一期迭代结束后都总结这次迭代遇到的问题，持续优化，提高效率\n\n开发环境\n开发环境和git分支是一一对应的。\n\n版本开发环境 - dev/x.x.x 版本分支\n测试/联调环境 - qa/qa1，qa/qa2，qa/qa3 3个测试环境和分支\n预发布/验收环境 - release分支\n正式线上环境 - master分支\n\nGit操作场景这里我们按照实际开发流程和实际场景来解说怎么使用git\n\n开启新版本迭代\n操作步骤\n从master分支创建一个版本分支\n创建版本分支后根据不同的端做不同的处理\n前端：需要把接口版本好改为当前迭代的接口版本号\n后端：先创建对应当前迭代的接口版本好控制器和路由，然后合并就版本的控制器更变。\n\n\n\n开发周期版本提测/bug修复提测\n提验收必须从版本分支合并qa分支\n\n操作步骤\n版本分支合并(merge)对应的测试分支(qa)\n版本分支代码合并后对应的qa环境会自动部署代码到对应的环境服务器上\n\n开发周期版本提验收/bug修复提验收 提测必须从版本分支合并验收(release)分支\n操作步骤\n版本分支合并(merge)验收分支(release)\n版本分支代码合并release环境会自动部署代码到环境服务器上\n\n\n如果是修复bug，就要先合并对应的qa分支后合并release分支。\n\n使用前版本修复上线流程\n操作步骤\n使用当前正式所在的版本找到对应的版本分支作为修复分支\n修复完成后合并对应的qa环境提测，然后提醒测试开始回归测试修复\n测试环境测试通过后把修复分支合并release分支，然后提醒测试在验收环境验收修复\n验收通过后，就可以通知开发组长以上的负责人合并master分支上线，然后通知测试在线上回归测试\n在线上回归通过后，就可以把修复分支分别合并到当前迭代版本分支\n\n紧急修复上线流程\n如果当前bug是很严重的，影响到用户使用的才需要使用紧急修复上线流程\n紧急修复上线必须先创建紧急修复(hotfix)分支\n\n操作步骤\n首先使用master分支创建紧急修复分支(hotfix/xxxx) - 使用hotfix前缀\n修复完成后合并对应的qa环境提测，然后提醒测试开始回归测试修复\n测试环境测试通过后把修复分支合并release分支，然后提醒测试在验收环境验收修复\n验收通过后，就可以通知开发组长以上的负责人合并master分支上线，然后通知测试在线上回归测试\n在线上回归通过后，就可以把修复分支分别合并到前版本分支和当前迭代版本分支\n最后在本地(local)和远程(origin)删除修复分支\n\n后端代码部署操作流程\n因为后端把不同模块都独立成一个composer包，所以git合并和部署流程跟前端是有区别的。这里分开来说明流程。\n\n操作步骤\n首先用每个模块的版本分支合并对应的qa分支\n然后切换到Foundation应用，然后推送对应的环境发起环境部署\n\n\n如果涉及多个模块需要同时发布，那就先把所有模块先合并好环境分支，然后再推Foundation。因为Foundation的某个环境启动了部署，必须部署完后才能发起下一次部署。\n\n","slug":"20190326-yqy-git-standard1.0","date":"2019-03-26T07:07:43.000Z","categories_index":"Git","tags_index":"git","author_index":"络擎"},{"id":"ede919be316f4f79677d41980bcb9458","title":"谈谈敏捷开发","content":"\n谈谈敏捷开发\n小步快跑、敏捷开发\n真实的敏捷开发\n后注\n\n谈谈敏捷开发好久没有更新一下博客，最近有在尝试新的领域，可是一直没能积累下什么重要的知识、或者形成了什么重要的知识体系，就没能写下什么有意义的记录。可是很偶然的机会看到一个视频，里面讲述的，乔布斯谈论关于【流程与人才】的理解，基本可以总结为：苹果没有像 IBM 一样衰落，很大一部分原因是苹果没有执行像 IBM 一样严格的流程管理，使得有能力、有才华的人才能够不受大公司中条条框框的约束，充分发挥自己优势，最终促使苹果一次又一次的震惊世界。\n看到这个视频的时候，脑子中转过了好多好多的话语，没能按耐住自己的情绪，终究还是在 Twitter 中直接开喷。当然，喷的并不是乔布斯或者是他的言论，乔帮主在国内一波又一波媒体、开发者的吹捧下，早就已经走上了“冰封王座”。他的一生、创办苹果的风风雨雨，相信拜读过《乔布斯传》的人都能已经耳熟能详了，这里不再细说。总而言之，对于笔者自身，远远还达不到批判他的言辞的资格。\n\n\n\n\n\n\n\n\n\n废话说了那么多，结果原来只是像表达自己的弱小\n乔布斯确实过于优秀了，以至于越来越多的年轻人、创业者，都想要向他学习，见贤思齐焉。而学习最简单不过的方式，就是模仿。现在越来越容易听到那些晦涩难懂，可是由显得高端深奥的词汇。似乎在这种谈吐中更容易体现出自身对于产品思考的深入。\n“把握用户体验”，“重新定义 XX”，甚至 “打破流程”。“ IBM 之所以没落，就是因为他大公司中繁重的流程，约束的条条框框。” 所以我们要注重人才的才华展示，淡化流程。乔布斯所表达的观点，我们全盘接受。\n这样子的学习，简单至极。\n流程不再重要了。—— 这就是为什么现在产品经理跟开发工程师之间存在如此对立的原因。\n当然，其实乔布斯并非推动国内各大企业打破传统、废除流程的唯一功臣，另外一个更广为人知的，当然是数早已被广为人知的、被誉为中国第一产品经理的 —— 张小龙。如果你不知道这个人的话，你可以点击 (Ctrl+W) 组合键，快速查询这个人的相关信息。^_^ 得益于他的知名度以及微信的成功，“打破流程”、“简化流程”、“把握用户体验” 获得了一个更加接地气的名称 —— “小步快跑，敏捷开发”。\n对比于传统应用开发方式，敏捷开发在当前互联网形式上确为更加合适，毫不夸张的说，如果目前的产品开发还按照从前的开发形式，普通创业公司绝大部分会在产品推出之前，就将所有的开发经费耗光。这个时候没有任何知名度、也没有成型的产品，根本无从谈起融资以及上市。\n小步快跑、敏捷开发仔细考虑，其实这种开发方式在起步阶段是比较合理的。一周一个小版本，一个月一个大版本，对每次开发的新功能做好足够的调研以及打点统计，能够在不进行市场调查的前提上获取用户对于功能的喜好程度，从而在后续的开发中对特定的功能进行资源的倾斜，更大程度上去取悦用户。不得不说，微信在初期发展中，摸索到了摇一摇以及朋友圈这两大功能，然后持续在上面增加功能，优化体验，让用户真正的粘附在了微信生态上，也算是对小步快跑、敏捷开发的很好体现。微信的成功，也让更多的公司相信这种开发模式的正确性。\n我们来仔细捋一下这种开发模式的要点：\n\n小版本周期短\n小版本所携带新功能有针对性\n开发过程中对新功能做好打点统计\n产品上线后进行需求复盘，通过统计上报，得知用户对于新功能的喜好程度\n对下一新版本的开发计划进行评估\n\n其中，复盘步骤对于敏捷开发的模式尤为重要。并且不仅是产品经理，包括开发人员都需要参与到复盘的步骤中。对于一个开发人员，得知自己所开发功能受到用户的喜爱，自身对于下个版本的开发积极性也会有相应的提高。\n真实的敏捷开发可是，有多少公司又能很好地在版本迭代的过程中持续遵循上述的要点呢？不少的公司更多的只是喊着敏捷开发的口号，在更短的时间内，往产品中堆砌着更多的功能，从而导致开发人员在长时间内一直保持着难以接受的开发强度，最终导致人员的流失，项目的失败。\n笔者从自身的工作环境中，感受到两点：\n\n老板过多地参与进项目开发的细节中\n复盘步骤的缺失，或者复盘步骤对于产品经理们的负反馈缺失\n\n笔者对于第一点真是深有体会。其实老板们关注细节无可厚非，可是过多的参与到项目开发中，很容易导致到开发节奏混乱，无法保持小版本迭代的步骤中。因为版本开发迭代期间，并不会频繁地推送到老板处体验，只能在项目上线阶段提交给老板进行上线前的最后体验。正常情况下，老板应该对这个功能开发进行最后的确认，确认这个版本是否与开发初期所定下的发展方向一致，而不应该对细节进行过多的反馈，一来这个环节在开发过程中早就经过产品经理的把控；二来开发人员、乃至于产品经理，都很难对老板所提出的细节要求说不，容易导致项目进度一拖再拖。三来甚至会过度打击产品经理的积极性，最终导致产品经理不再创新，只会揣测老板的心思。\n即便是成功至此的微信，笔者感觉它都已经不再是认真遵循着敏捷开发的模式了，大家可以从微信的招聘口号中可以感受一下：\n\n\n\n\n\n\n\n\n\n做一个伟大的产品来取悦–自己。\n后注毕竟这片文章只是有感而发，想到哪写到哪，尚未经过深入思考。请读者们轻喷。\n","slug":"20190311-about-agility-dev","date":"2019-03-11T04:00:00.000Z","categories_index":"网站收藏","tags_index":"agile","author_index":"络擎"},{"id":"28e2c50cddef1ae63b6743f914e9f466","title":"JavaScript时间戳总结","content":"javascript时间戳经常用到，现在总结一下。\n一、时间戳函数&lt;script&gt;   \nfunction getLocalTime(nS) &#123;   \n   return new Date(parseInt(nS) * 1000).toLocaleString().replace(&#x2F;:\\d&#123;1,2&#125;$&#x2F;,&#39; &#39;);   \n&#125;   \nalert(getLocalTime(1293072805));   \n&lt;&#x2F;script&gt; \n也可以用如下，想取几位就几位，注意，空格也算！\n&lt;script&gt;   \nfunction getLocalTime(nS) &#123;   \n    return new Date(parseInt(nS) * 1000).toLocaleString().substr(0,14)&#125;   \nalert(getLocalTime(1293072805));   \n&lt;&#x2F;script&gt;   \n\n如果想弹出：2018-02-12 14:00:00这个格式的也好办\n&lt;script&gt;   \nfunction getLocalTime(nS) &#123;   \n   return new Date(parseInt(nS) * 1000).toLocaleString().replace(&#x2F;年|月&#x2F;g, &quot;-&quot;).replace(&#x2F;日&#x2F;g, &quot; &quot;);    \n&#125;   \nalert(getLocalTime(1177824835));   \n&lt;&#x2F;script&gt;\n\n另外，也可以这么写：\nfunction   formatDate(now)   &#123;   \n  var   year&#x3D;now.getYear();   \n  var   month&#x3D;now.getMonth()+1;   \n  var   date&#x3D;now.getDate();   \n  var   hour&#x3D;now.getHours();   \n  var   minute&#x3D;now.getMinutes();   \n  var   second&#x3D;now.getSeconds();   \n  return   year+&quot;-&quot;+month+&quot;-&quot;+date+&quot;   &quot;+hour+&quot;:&quot;+minute+&quot;:&quot;+second;   \n&#125;\n  var   d&#x3D;new   Date(1230999938);   \n  alert(formatDate(d));\n\n二、知识普及1、当前系统区域设置格式(toLocaleDateString和toLocaleTimeString)例子:(new Date()).toLocaleDateString() + &quot; &quot; + (new Date()).toLocaleTimeString() \n结果: 2018年2月12日 16:13:11 \n\n2.普通字符串(toDateString和toTimeString)例子: (new Date()).toDateString() + &quot; &quot; + (new Date()).toTimeString() \n结果:Tue Jan 29 2008 16:13:11 UTC+0800 \n\n3.格林威治标准时间(toGMTString)例子: (new Date()).toGMTString() \n结果:Tue, 29 Jan 2008 08:13:11 UTC \n\n4.全球标准时间(toUTCString)例子: (new Date()).toUTCString() \n结果:Tue, 29 Jan 2008 08:13:11 UTC \n\n5.Date对象字符串(toString)例子: (new Date()).toString() \n结果:Tue Jan 29 16:13:11 UTC+0800 2008\n\nDate对象构造函数 \nDate对象具有多种构造函数。 \nnew Date() \nnew Date(milliseconds) \nnew Date(datestring) \nnew Date(year, month) \nnew Date(year, month, day) \nnew Date(year, month, day, hours) \nnew Date(year, month, day, hours, minutes) \nnew Date(year, month, day, hours, minutes, seconds) \nnew Date(year, month, day, hours, minutes, seconds, microseconds) \nDate对象构造函数参数说明 \nmilliseconds - 距离JavaScript内部定义的起始时间1970年1月1日的毫秒数 \ndatestring - 字符串代表的日期与时间。此字符串可以使用Date.parse()转换 \nyear - 四位数的年份，如果取值为0-99，则在其之上加上1900 \nmonth - 0(代表一月)-11(代表十二月)之间的月份 \nday - 1-31之间的日期 \nhours - 0(代表午夜)-23之间的小时数 \nminutes - 0-59之间的分钟数 \nseconds - 0-59之间的秒数 \nmicroseconds - 0-999之间的毫秒数 \nDate对象返回值 \n如果没有任何参数，将返回当前日期 \n如果参数为一个数字，将数字视为毫秒值，转换为日期 \n如果参数为一个字符串，将字符串视为日期的字符串表示，转换为日期 \n还可以使用六个构造函数精确定义，并返回时间 \n示例 \nvar d1 &#x3D; new Date(); \ndocument.write(d1.toString()); \nvar d2 &#x3D; new Date(&quot;2009-08-08 12:12:12); \ndocument.write(d2.toString()); \nvar d3 &#x3D; new Date(2009, 8, 8); \ndocument.write(d3.toString()); \nDate做为JavaScript的一种内置对象，必须使用new的方式创建。 \nDate对象在JavaScript内部的表示方式是，距1970年1月1日午夜(GMT时间)的毫秒数(时间戳)，我们在这里也把Date的内部表示形式称为时间戳。可以使用getTime()将Date对象转换为Date的时间戳，方法setTime()可以把Date的时间戳转换为Date的标准形式。 \nDate函数使用语法 \ndate.方法名(参数1,参数2,...); \nDate.方法名(); \ndate代表一个日期对象的实例，Date代表日期对象，date.方法名调用的为对象的成员函数 \nDate.方法名调用的为对象的静态函数 \n示例 \nvar d&#x3D;new Date(); \nvar d2&#x3D;Date.UTC(); \nJavaScript_Date函数按功能分类 \n日期获取类函数 \nDate() 函数 -- Date对象的构造函数 \ngetDate() 函数 -- 返回date对象中的月份中的天数(1-31) \ngetDay()函数 -- 返回date对象中的星期中的天数(0-6) \ngetFullYear() 函数 -- 返回date对象中的四位数年份 \ngetHours()函数 -- 返回date对象中的小时数(0-23) \ngetMilliseconds() 函数 -- 返回date对象中的毫秒数(0-999) \ngetMinutes() 函数 -- 返回date对象中的分钟数(0-59) \ngetMonth() 函数 -- 返回date对象中的月份数(0-11) \ngetSeconds() 函数 -- 返回date对象中的秒数(0-59) \ngetTime() 函数 -- 返回date对象的时间戳表示法(毫秒表示) \ngetTimezoneOffset() 函数 -- 返回本地时间与用UTC表示当前日期的时间差，以分钟为单位 \ngetUTCDate() 函数 -- 返回date对象中用世界标准时间(UTC)表示的月份中的一天(1-31) \ngetUTCDay() 函数 -- 返回date对象中用世界标准时间(UTC)表示的周中的一天(0-6) \ngetUTCFullYear() 函数 -- 返回date对象中用世界标准时间(UTC)表示的四位年份 \ngetUTCHours() 函数 -- 返回date对象中用世界标准时间(UTC)表示的小时数(0-23) \ngetUTCMilliseconds() 函数 -- 返回date对象中用世界标准时间(UTC)表示的毫秒数(0-999) \ngetUTCMinutes() 函数 -- 返回date对象中用世界标准时间(UTC)表示的分钟数(0-59) \ngetUTCMonth() 函数 -- 返回date对象中用世界标准时间(UTC)表示的月份数(0-11) \ngetUTCSeconds() 函数 -- 返回date对象中用世界标准时间(UTC)表示的秒数(0-59) \ngetYear() 函数 -- 返回date对象的年份(真实年份减去1900) \nDate.UTC()函数 -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳) \n日期设置类函数 \nsetDate() 函数 -- 设置date对象中月份的一天，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetFullYear() 函数 -- 设置date对象中的年份，月份和天，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetHours() 函数 -- 设置date对象的小时，分钟，秒和毫秒，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetMilliseconds() 函数 -- 设置date对象的毫秒数，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetMinutes() 函数 -- 设置date对象的分钟，秒，毫秒，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetMonth() 函数 -- 设置date对象中月份，天，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetSeconds() 函数 -- 设置date对象中月份的一天，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetTime() 函数 -- 使用毫秒数设置date对象，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetUTCDate() 函数 -- 设置date对象中用世界标准时间(UTC)表示的月份的一天，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetUTCFullYear() 函数 -- 设置date对象中用世界标准时间(UTC)表示的年份，月份和天，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetUTCHours() 函数 --- 设置date对象中用世界标准时间(UTC)表示的小时，分钟，秒和毫秒，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetUTCMilliseconds() 函数 -- 设置date对象中用世界标准时间(UTC)表示的毫秒数，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetUTCMinutes() 函数 -- 设置date对象中用世界标准时间(UTC)表示的分钟，秒，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetUTCMonth() 函数 -- 设置date对象中用世界标准时间(UTC)表示的月份，天，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetUTCSeconds() 函数 -- 设置date对象中用世界标准时间(UTC)表示的秒，毫秒，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetYear() 函数 -- 设置date对象的年份(真实年份减去1900) \n日期打印类函数 \ntoDateString() 函数 -- 返回date对象的日期部分的字符串表示 \ntoGMTString() 函数 -- 返回date对象的格林威治时间(GMT)的字符串表示 \ntoLocaleDateString函数 -- 返回date对象的日期部分的本地化字符串 \ntoLocaleTimeString函数 -- 返回date对象的时间部分的本地化字符串 \ntoTimeString()函数 -- 返回date对象的时间部分的字符串 \ntoUTCString函数 -- 返回date对象的世界标准时间(UTC)的字符串表示 \n日期解析类函数 \nDate.parse() 函数 -- 解析一个日期的字符串，并返回该日期距1970年1月1日午夜之间的毫秒数(时间戳) \nJavaScript_Date函数按照字母分类 \nDate() 函数 -- Date对象的构造函数 \ngetDate() 函数 -- 返回date对象中的月份中的天数(1-31) \ngetDay()函数 -- 返回date对象中的星期中的天数(0-6) \ngetFullYear() 函数 -- 返回date对象中的四位数年份 \ngetHours()函数 -- 返回date对象中的小时数(0-23) \ngetMilliseconds() 函数 -- 返回date对象中的毫秒数(0-999) \ngetMinutes() 函数 -- 返回date对象中的分钟数(0-59) \ngetMonth() 函数 -- 返回date对象中的月份数(0-11) \ngetSeconds() 函数 -- 返回date对象中的秒数(0-59) \ngetTime() 函数 -- 返回date对象的时间戳表示法(毫秒表示) \ngetTimezoneOffset() 函数 -- 返回本地时间与用UTC表示当前日期的时间差，以分钟为单位 \ngetUTCDate() 函数 -- 返回date对象中用世界标准时间(UTC)表示的月份中的一天(1-31) \ngetUTCDay() 函数 -- 返回date对象中用世界标准时间(UTC)表示的周中的一天(0-6) \ngetUTCFullYear() 函数 -- 返回date对象中用世界标准时间(UTC)表示的四位年份 \ngetUTCHours() 函数 -- 返回date对象中用世界标准时间(UTC)表示的小时数(0-23) \ngetUTCMilliseconds() 函数 -- 返回date对象中用世界标准时间(UTC)表示的毫秒数(0-999) \ngetUTCMinutes() 函数 -- 返回date对象中用世界标准时间(UTC)表示的分钟数(0-59) \ngetUTCMonth() 函数 -- 返回date对象中用世界标准时间(UTC)表示的月份数(0-11) \ngetUTCSeconds() 函数 -- 返回date对象中用世界标准时间(UTC)表示的秒数(0-59) \ngetYear() 函数 -- 返回date对象的年份(真实年份减去1900) \nDate.parse() 函数 -- 解析一个日期的字符串，并返回该日期距1970年1月1日午夜之间的毫秒数(时间戳) \nsetDate() 函数 -- 设置date对象中月份的一天，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetFullYear() 函数 -- 设置date对象中的年份，月份和天，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetHours() 函数 -- 设置date对象的小时，分钟，秒和毫秒，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetMilliseconds() 函数 -- 设置date对象的毫秒数，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetMinutes() 函数 -- 设置date对象的分钟，秒，毫秒，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetMonth() 函数 -- 设置date对象中月份，天，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetSeconds() 函数 -- 设置date对象中月份的一天，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetTime() 函数 -- 使用毫秒数设置date对象，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetUTCDate() 函数 -- 设置date对象中用世界标准时间(UTC)表示的月份的一天，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetUTCFullYear() 函数 -- 设置date对象中用世界标准时间(UTC)表示的年份，月份和天，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetUTCHours() 函数 --- 设置date对象中用世界标准时间(UTC)表示的小时，分钟，秒和毫秒，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetUTCMilliseconds() 函数 -- 设置date对象中用世界标准时间(UTC)表示的毫秒数，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetUTCMinutes() 函数 -- 设置date对象中用世界标准时间(UTC)表示的分钟，秒，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetUTCMonth() 函数 -- 设置date对象中用世界标准时间(UTC)表示的月份，天，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetUTCSeconds() 函数 -- 设置date对象中用世界标准时间(UTC)表示的秒，毫秒，并返回date对象距1970年1月1日午夜之间的毫秒数(时间戳) \nsetYear() 函数 -- 设置date对象的年份(真实年份减去1900) \ntoDateString() 函数 -- 返回date对象的日期部分的字符串表示 \ntoGMTString() 函数 -- 返回date对象的格林威治时间(GMT)的字符串表示 \ntoLocaleDateString函数 -- 返回date对象的日期部分的本地化字符串 \ntoLocaleTimeString函数 -- 返回date对象的时间部分的本地化字符串 \ntoTimeString()函数 -- 返回date对象的时间部分的字符串 \ntoUTCString函数 -- 返回date对象的世界标准时间(UTC)的字符串表示 \nDate.UTC()函数 -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)\n\n三、Javascript的时间戳和php的时间戳转换js的时间戳通常是13位，php的时间戳是10位,转换函数如下：\nvar nowtime &#x3D; (new Date).getTime();&#x2F;*当前时间戳*&#x2F;   \n&#x2F;*转换时间，计算差值*&#x2F;   \nfunction comptime(beginTime,endTime)&#123;   \n  var secondNum &#x3D; parseInt((endTime-beginTime*1000)&#x2F;1000);&#x2F;&#x2F;计算时间戳差值      \n\n  if(secondNum&gt;&#x3D;0&amp;&amp;secondNum&lt;60)&#123;   \n      return secondNum+&#39;秒前&#39;;   \n  &#125;   \n  else if (secondNum&gt;&#x3D;60&amp;&amp;secondNum&lt;3600)&#123;   \n      var nTime&#x3D;parseInt(secondNum&#x2F;60);   \n      return nTime+&#39;分钟前&#39;;   \n  &#125;   \n  else if (secondNum&gt;&#x3D;3600&amp;&amp;secondNum&lt;3600*24)&#123;   \n      var nTime&#x3D;parseInt(secondNum&#x2F;3600);   \n      return nTime+&#39;小时前&#39;;   \n  &#125;   \n  else&#123;   \n      var nTime &#x3D; parseInt(secondNum&#x2F;86400);   \n      return nTime+&#39;天前&#39;;   \n  &#125;   \n&#125;   \n\nt &#x3D; comptime(&quot;1324362556&quot;,nowtime);&#x2F;&#x2F;timestamp为PHP通过ajax回传的时间戳   \n\nalert(t); ","slug":"20180212-javascript-time-stamp","date":"2018-02-12T06:22:00.000Z","categories_index":"JavaScript","tags_index":"js","author_index":"络擎"},{"id":"a73d625d9b33f42affb7d0477c9b4d7c","title":"前端开发必备网站汇总","content":"前言写个前端开发者，包含行业大牛博客，前端社区，开发工具，各种预编译工具打包工具和项目构建工具！更多内容持续更新…\n大牛博客阮一峰博客： http://www.ruanyifeng.com/blog/\n愚人码头博客： http://www.css88.com/\n勾三股四博客： http://jiongks.name/\n前端博客： http://caibaojian.com/\n大漠穷秋： https://my.oschina.net/mumu/\n视频教程极客学院： http://www.jikexueyuan.com/\n慕课网视频教程： http://www.imooc.com/\n前端社区前端网： http://www.qdfuns.com/\n掘金： https://gold.xitu.io/\nfrontopen： http://www.frontopen.com/\nw3cplus： http://www.w3cplus.com/\n大前端： http://www.daqianduan.com/\n伯乐在线： http://www.jobbole.com/\n前端里： http://www.yyyweb.com/\n爱思资源网： http://www.aseoe.com/\n前端观察： https://www.qianduan.net/\n前端开发俱乐部： http://www.html-js.cn/\n前端工具类汇总前端开发仓库： http://code.ciaoca.com/\n极客学院wiki： http://wiki.jikexueyuan.com/\n前端在线编辑器： http://runjs.cn/code\nBootstrap中文网开源项目免费CDN： http://www.bootcdn.cn/\n程序员综合github： https://github.com/\n开源中国： https://www.oschina.net/\nCSDN： http://www.csdn.net/\n博客园： http://www.cnblogs.com/\n框架文档VUE中文： vuejs.org.cn\nVUE 2.0教程： https://vuefe.cn/v2/guide/\nReactJs中文教程： http://reactjs.cn/react/docs/getting-started-zh-CN.html\n菜鸟教程： www.runoob.com\nECMAScript 6： http://es6.ruanyifeng.com/\nAngularjs中文教程： http://www.apjs.net/\nRequirejs中文： http://www.requirejs.cn/\nnode中文网： http://cnodejs.org/getstart\nexpress中文网： http://www.expressjs.com.cn/\n预编译、打包、构建工具less： http://less.bootcss.com/\nsass： http://sass.bootcss.com/\ncoffeescript： http://coffee-script.org/\npugjs（也就是Jade）： https://github.com/pugjs/pug\nbabeljs： http://babeljs.cn/\ngrunt中文网： http://www.gruntjs.net/\ngulp中文网： http://www.gulpjs.com.cn/\nwebpack中文网： http://webpackdoc.com/\n前端团队博客腾讯前端团队\nhttp://www.alloyteam.com/\nhttps://github.com/AlloyTeam/\n淘宝前端团队\nhttp://taobaofed.org/\nhttps://github.com/taobaofed\nFirefox技术文档\nhttps://developer.mozilla.org/zh-CN/\nhttps://hacks.mozilla.org/\n开发工具IDEsublime： www.sublimetext.com/\nvim： http://www.vim.org/download.php\nHbuilder： www.dcloud.io\nwebstorm： http://www.jetbrains.com/webstorm/\nIntelliJ IDEA： http://www.jetbrains.com/idea/\n更多内容持续更新，推荐收藏本文…\n","slug":"20180210-web-development-necessary","date":"2018-02-10T07:00:00.000Z","categories_index":"敏捷开发","tags_index":"web","author_index":"络擎"}]