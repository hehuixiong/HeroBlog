{"title":"TypeScript进阶之路","uid":"cdaf5778a92658d6959a7b30d99c6bfc","slug":"20220218-typescript-advanced","date":"2022-02-18T06:00:00.000Z","updated":"2022-02-24T09:19:39.882Z","comments":true,"path":"api/articles/20220218-typescript-advanced.json","keywords":null,"cover":"https://cdn.ithhx.cn/img-blog/20220223175131.png","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>随着项目越来越大,市面上所使用的五花八门插件库也越来越多,随便一个项目都少说会1w+行代码以上,导致项目维护越来越差。尤其上在开发原生<strong>JavaScript</strong>的时候从中找<strong>Bug</strong>更是难如登天。<strong>TypeScript</strong>犹如<strong>the Saviour</strong>让更多开发者得心应手,也是现在开发大型工程化项目必不可缺少的一部分语言了…</p>\n<h2 id=\"一、TypeScript-是什么\"><a href=\"#一、TypeScript-是什么\" class=\"headerlink\" title=\"一、TypeScript 是什么?\"></a>一、TypeScript 是什么?</h2><p><strong>TypeScript</strong> 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。<br>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。下图显示了 TypeScript 与 ES5、ES2015 和 ES2016 之间的关系：<br><img src=\"https://cdn.ithhx.cn/img-blog/20220223170549.png\" style=\"width: 400px;margin-top: 40px;\" /></p>\n<h4 id=\"1-1-TypeScript-与-JavaScript-的区别\"><a href=\"#1-1-TypeScript-与-JavaScript-的区别\" class=\"headerlink\" title=\"1.1 TypeScript 与 JavaScript 的区别\"></a>1.1 TypeScript 与 JavaScript 的区别</h4><table>\n<thead>\n<tr>\n<th align=\"left\">-</th>\n<th align=\"left\">TypeScript</th>\n<th align=\"left\">JavaScript</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">JavaScript 的超集用于解决大型项目的代码复杂性</td>\n<td align=\"left\">一种脚本语言，用于创建动态网页</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">可以在编译期间发现并纠正错误</td>\n<td align=\"left\">作为一种解释型语言，只能在运行时发现错误</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">强类型，支持静态和动态类型</td>\n<td align=\"left\">弱类型，没有静态类型选项</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">最终被编译成 JavaScript 代码，使浏览器可以理解</td>\n<td align=\"left\">可以直接在浏览器中使用</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">支持模块、泛型和接口</td>\n<td align=\"left\">不支持模块，泛型或接口</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">社区的支持仍在增长，而且还不是很大</td>\n<td align=\"left\">大量的社区支持以及大量文档和解决问题的支持</td>\n</tr>\n</tbody></table>\n<h4 id=\"1-2-获取-TypeScript\"><a href=\"#1-2-获取-TypeScript\" class=\"headerlink\" title=\"1.2 获取 TypeScript\"></a>1.2 获取 TypeScript</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>命令行的 TypeScript 编译器可以使用 npm 包管理器来安装。</p></blockquote>\n<h4 id=\"1-安装-TypeScript\"><a href=\"#1-安装-TypeScript\" class=\"headerlink\" title=\"#1.安装 TypeScript\"></a>#1.安装 TypeScript</h4><pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ npm install -g typescript</code></pre>\n\n<h4 id=\"2-验证-TypeScript\"><a href=\"#2-验证-TypeScript\" class=\"headerlink\" title=\"#2.验证 TypeScript\"></a>#2.验证 TypeScript</h4><pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ tsc -v \n# Version 4.0.2</code></pre>\n\n<h4 id=\"3-编译-TypeScript-文件\"><a href=\"#3-编译-TypeScript-文件\" class=\"headerlink\" title=\"#3.编译 TypeScript 文件\"></a>#3.编译 TypeScript 文件</h4><pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">$ tsc helloworld.ts\n# helloworld.ts &#x3D;&gt; helloworld.js</code></pre>\n\n<p>当然，对刚入门 <strong>TypeScript</strong> 的小伙伴来说，也可以不用安装 <strong>typescript</strong>，而是直接使用线上的 <strong>TypeScript Playground</strong>来学习新的语法或新特性。通过配置 <strong>TS Config</strong> 的 <strong>Target</strong>，可以设置不同的编译目标，从而编译生成不同的目标代码。<br>下图示例中所设置的编译目标是<strong>ES5</strong>：</p>\n<p><img src=\"https://cdn.ithhx.cn/img-blog/20220223171955.png\"></p>\n<h4 id=\"1-3-典型-TypeScript-工作流程\"><a href=\"#1-3-典型-TypeScript-工作流程\" class=\"headerlink\" title=\"1.3 典型 TypeScript 工作流程\"></a>1.3 典型 TypeScript 工作流程</h4><p><img src=\"https://cdn.ithhx.cn/img-blog/20220223174847.png\"></p>\n<p>如你所见，在上图中包含 3 个 <strong>ts</strong> 文件：<strong>a.ts、b.ts</strong> 和 <strong>c.ts</strong>。这些文件将被TypeScript编译器，根据配置的编译选项编译成 3 个 <strong>js</strong> 文件，即 <strong>a.js、b.js 和 c.js</strong>。对于大多数使用 <strong>TypeScript</strong> 开发的 <strong>Web</strong> 项目，我们还会对编译生成的 <strong>js</strong> 文件进行打包处理，然后在进行部署。</p>\n<h4 id=\"1-4-TypeScript-初体验\"><a href=\"#1-4-TypeScript-初体验\" class=\"headerlink\" title=\"1.4 TypeScript 初体验\"></a>1.4 TypeScript 初体验</h4><p>新建一个 <strong>hello.ts</strong> 文件，并输入以下内容：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function greet(person: string) &#123;\n  return &#39;Hello, &#39; + person;\n&#125;\n \nconsole.log(greet(&quot;TypeScript&quot;));</code></pre>\n<p>观察以上编译后的输出结果，我们发现 <strong>person</strong> 参数的类型信息在编译后被擦除了。<strong>TypeScript</strong> 只会在编译阶段对类型进行静态检查，如果发现有错误，编译时就会报错。而在运行时，编译生成的 <strong>JS</strong> 与普通的 <strong>JavaScript</strong> 文件一样，并不会进行类型检查。</p>\n<h2 id=\"二、TypeScript-基础类型\"><a href=\"#二、TypeScript-基础类型\" class=\"headerlink\" title=\"二、TypeScript 基础类型\"></a>二、TypeScript 基础类型</h2><h4 id=\"2-1-Boolean-类型\"><a href=\"#2-1-Boolean-类型\" class=\"headerlink\" title=\"#2.1 Boolean 类型\"></a>#2.1 Boolean 类型</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let isDone: boolean &#x3D; false;\n&#x2F;&#x2F; ES5：var isDone &#x3D; false;</code></pre>\n\n<h4 id=\"2-2-Number-类型\"><a href=\"#2-2-Number-类型\" class=\"headerlink\" title=\"#2.2 Number 类型\"></a>#2.2 Number 类型</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let count: number &#x3D; 10;\n&#x2F;&#x2F; ES5：var count &#x3D; 10;</code></pre>\n<h4 id=\"2-3-String-类型\"><a href=\"#2-3-String-类型\" class=\"headerlink\" title=\"#2.3 String 类型\"></a>#2.3 String 类型</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let name: string &#x3D; &quot;semliker&quot;;\n&#x2F;&#x2F; ES5：var name &#x3D; &#39;semlinker&#39;;</code></pre>\n<h4 id=\"2-4-Symbol-类型\"><a href=\"#2-4-Symbol-类型\" class=\"headerlink\" title=\"#2.4 Symbol 类型\"></a>#2.4 Symbol 类型</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const sym &#x3D; Symbol();\nlet obj &#x3D; &#123;\n  [sym]: &quot;semlinker&quot;,\n&#125;;\nconsole.log(obj[sym]); &#x2F;&#x2F; semlinker </code></pre>\n<h4 id=\"2-5-Array-类型\"><a href=\"#2-5-Array-类型\" class=\"headerlink\" title=\"#2.5 Array 类型\"></a>#2.5 Array 类型</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let list: number[] &#x3D; [1, 2, 3];\n&#x2F;&#x2F; ES5：var list &#x3D; [1,2,3];\n \nlet list: Array&lt;number&gt; &#x3D; [1, 2, 3]; &#x2F;&#x2F; Array&lt;number&gt;泛型语法\n&#x2F;&#x2F; ES5：var list &#x3D; [1,2,3];</code></pre>\n<h4 id=\"2-6-Enum-类型\"><a href=\"#2-6-Enum-类型\" class=\"headerlink\" title=\"#2.6 Enum 类型\"></a>#2.6 Enum 类型</h4><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 <strong>TypeScript</strong> 支持数字的和基于字符串的枚举。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1.数字枚举</p></blockquote>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">enum Direction &#123;\n  NORTH,\n  SOUTH,\n  EAST,\n  WEST,\n&#125;\n \nlet dir: Direction &#x3D; Direction.NORTH;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>2.字符串枚举<br>在 <strong>TypeScript 2.4</strong> 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p></blockquote>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\">enum Direction &#123;\n  NORTH &#x3D; &quot;NORTH&quot;,\n  SOUTH &#x3D; &quot;SOUTH&quot;,\n  EAST &#x3D; &quot;EAST&quot;,\n  WEST &#x3D; &quot;WEST&quot;,\n&#125;</code></pre>\n<p>以上代码对应的<strong>ES5</strong>代码如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&quot;use strict&quot;;\nvar Direction;\n(function (Direction) &#123;\n    Direction[&quot;NORTH&quot;] &#x3D; &quot;NORTH&quot;;\n    Direction[&quot;SOUTH&quot;] &#x3D; &quot;SOUTH&quot;;\n    Direction[&quot;EAST&quot;] &#x3D; &quot;EAST&quot;;\n    Direction[&quot;WEST&quot;] &#x3D; &quot;WEST&quot;;\n&#125;)(Direction || (Direction &#x3D; &#123;&#125;));</code></pre>\n\n<p>通过观察数字枚举和字符串枚举的编译结果，我们可以知道数字枚举除了支持 从成员名称到成员值 的普通映射之外，它还支持 从成员值到成员名称 的反向映射：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">enum Direction &#123;\n  NORTH,\n  SOUTH,\n  EAST,\n  WEST,\n&#125;\n \nlet dirName &#x3D; Direction[0]; &#x2F;&#x2F; NORTH\nlet dirVal &#x3D; Direction[&quot;NORTH&quot;]; &#x2F;&#x2F; 0\n</code></pre>\n\n<p>另外，对于纯字符串枚举，我们不能省略任何初始化程序。而数字枚举如果没有显式设置值时，则会使用默认规则进行初始化。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>3.常量枚举<br>除了数字枚举和字符串枚举之外，还有一种特殊的枚举 —— 常量枚举。它是使用 const 关键字修饰的枚举，常量枚<br>举会使用内联语法，不会为枚举类型编译生成任何JavaScript。为了更好地理解这句话，我们来看一个具体的例子：</p></blockquote>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">const enum Direction &#123;\n  NORTH,\n  SOUTH,\n  EAST,\n  WEST,\n&#125;\n \nlet dir: Direction &#x3D; Direction.NORTH;</code></pre>\n\n<p>以上代码对应的<strong>ES5</strong>代码如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&quot;use strict&quot;;\nvar dir &#x3D; 0 &#x2F;* NORTH *&#x2F;;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>4.异构枚举<br>异构枚举的成员值是数字和字符串的混合：</p></blockquote>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">enum Enum &#123;\n  A,\n  B,\n  C &#x3D; &quot;C&quot;,\n  D &#x3D; &quot;D&quot;,\n  E &#x3D; 8,\n  F,\n&#125;</code></pre>\n\n<p>以上代码对于的 ES5 代码如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&quot;use strict&quot;;\nvar Enum;\n(function (Enum) &#123;\n    Enum[Enum[&quot;A&quot;] &#x3D; 0] &#x3D; &quot;A&quot;;\n    Enum[Enum[&quot;B&quot;] &#x3D; 1] &#x3D; &quot;B&quot;;\n    Enum[&quot;C&quot;] &#x3D; &quot;C&quot;;\n    Enum[&quot;D&quot;] &#x3D; &quot;D&quot;;\n    Enum[Enum[&quot;E&quot;] &#x3D; 8] &#x3D; &quot;E&quot;;\n    Enum[Enum[&quot;F&quot;] &#x3D; 9] &#x3D; &quot;F&quot;;\n&#125;)(Enum || (Enum &#x3D; &#123;&#125;));</code></pre>\n\n<p>通过观察上述生成的 ES5 代码，我们可以发现数字枚举相对字符串枚举多了 “反向映射”：</p>\n<pre class=\"line-numbers language-less\" data-language=\"less\"><code class=\"language-less\">console.log(Enum.A) &#x2F;&#x2F;输出：0\nconsole.log(Enum[0]) &#x2F;&#x2F; 输出：A</code></pre>\n\n<h4 id=\"2-7-Any-类型\"><a href=\"#2-7-Any-类型\" class=\"headerlink\" title=\"#2.7 Any 类型\"></a>#2.7 Any 类型</h4><p>在<strong>TypeScript</strong>中，任何类型都可以被归为<strong>any</strong>类型。这让<strong>any</strong>类型成为了类型系统的顶级类型（也被称作全局超级类型）。</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\">let notSure: any &#x3D; 666;\nnotSure &#x3D; &quot;semlinker&quot;;\nnotSure &#x3D; false;</code></pre>\n\n<p><strong>any</strong>类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由：<strong>TypeScript</strong> 允许我们对<strong>any</strong>类型的值执行任何操作，而无需事先执行任何形式的检查。比如：</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">let value: any;\n \nvalue.foo.bar; &#x2F;&#x2F; OK\nvalue.trim(); &#x2F;&#x2F; OK\nvalue(); &#x2F;&#x2F; OK\nnew value(); &#x2F;&#x2F; OK\nvalue[0][1]; &#x2F;&#x2F; OK</code></pre>\n<p>在许多场景下，这太宽松了。使用 any 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 any 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 any 带来的问题，TypeScript 3.0 引入了 unknown`类型。</p>\n<h4 id=\"2-8-Unknown-类型\"><a href=\"#2-8-Unknown-类型\" class=\"headerlink\" title=\"#2.8 Unknown 类型\"></a>#2.8 Unknown 类型</h4><p>就像所有类型都可以赋值给 <strong>any</strong>，所有类型也都可以赋值给 unknown。这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any）。下面我们来看一下 unknown 类型的使用示例：</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">let value: unknown;\n \nvalue &#x3D; true; &#x2F;&#x2F; OK\nvalue &#x3D; 42; &#x2F;&#x2F; OK\nvalue &#x3D; &quot;Hello World&quot;; &#x2F;&#x2F; OK\nvalue &#x3D; []; &#x2F;&#x2F; OK\nvalue &#x3D; &#123;&#125;; &#x2F;&#x2F; OK\nvalue &#x3D; Math.random; &#x2F;&#x2F; OK\nvalue &#x3D; null; &#x2F;&#x2F; OK\nvalue &#x3D; undefined; &#x2F;&#x2F; OK\nvalue &#x3D; new TypeError(); &#x2F;&#x2F; OK\nvalue &#x3D; Symbol(&quot;type&quot;); &#x2F;&#x2F; OK\n</code></pre>\n\n<p>对 <strong>value</strong> 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 <strong>unknown</strong> 的值赋值给其他类型的变量时会发生什么？</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">let value: unknown;\n \nlet value1: unknown &#x3D; value; &#x2F;&#x2F; OK\nlet value2: any &#x3D; value; &#x2F;&#x2F; OK\nlet value3: boolean &#x3D; value; &#x2F;&#x2F; Error\nlet value4: number &#x3D; value; &#x2F;&#x2F; Error\nlet value5: string &#x3D; value; &#x2F;&#x2F; Error\nlet value6: object &#x3D; value; &#x2F;&#x2F; Error\nlet value7: any[] &#x3D; value; &#x2F;&#x2F; Error\nlet value8: Function &#x3D; value; &#x2F;&#x2F; Error</code></pre>\n\n<p><strong>unknown</strong>类型只能被赋值给 any 类型和 unknown 类型本身。直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 unknown 类型的值。毕竟我们不知道变量 value 中存储了什么类型的值。<br>现在让我们看看当我们尝试对类型为<strong>unknown</strong>的值执行操作时会发生什么。以下是我们在之前<strong>any</strong>章节看过的相同操作：</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">let value: unknown;\n \nvalue.foo.bar; &#x2F;&#x2F; Error\nvalue.trim(); &#x2F;&#x2F; Error\nvalue(); &#x2F;&#x2F; Error\nnew value(); &#x2F;&#x2F; Error\nvalue[0][1]; &#x2F;&#x2F; Error</code></pre>\n<p>将 value变量类型设置为unknown后，这些操作都不再被认为是类型正确的。通过将 any 类型改变为unknown类型，我们已将允许所有更改的默认设置，更改为禁止任何更改。</p>\n<h4 id=\"2-9-Tuple-类型\"><a href=\"#2-9-Tuple-类型\" class=\"headerlink\" title=\"#2.9 Tuple 类型\"></a>#2.9 Tuple 类型</h4><p>众所周知，数组一般由同种类型的值组成，但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组。<br>元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须提供每个属性的值。为了更直观地理解元组的概念，我们来看一个具体的例子：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let tupleType: [string, boolean];\ntupleType &#x3D; [&quot;semlinker&quot;, true];</code></pre>\n<p>在上面代码中，我们定义了一个名为tupleType的变量，它的类型是一个类型数组 [string, boolean]，然后我们按照正确的类型依次初始化tupleType变量。与数组一样，我们可以通过下标来访问元组中的元素：</p>\n<pre class=\"line-numbers language-scss\" data-language=\"scss\"><code class=\"language-scss\">console.log(tupleType[0]); &#x2F;&#x2F; semlinker\nconsole.log(tupleType[1]); &#x2F;&#x2F; true</code></pre>\n<p>在元组初始化的时候，如果出现类型不匹配的话，比如：</p>\n<pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\">tupleType &#x3D; [true, &quot;semlinker&quot;];</code></pre>\n\n<p>此时，TypeScript 编译器会提示以下错误信息：</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">[0]: Type &#39;true&#39; is not assignable to type &#39;string&#39;.\n[1]: Type &#39;string&#39; is not assignable to type &#39;boolean&#39;.</code></pre>\n\n<p>很明显是因为类型不匹配导致的。在元组初始化的时候，我们还必须提供每个属性的值，不然也会出现错误，比如：</p>\n<pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\">tupleType &#x3D; [&quot;semlinker&quot;];</code></pre>\n\n<p>此时，TypeScript编译器会提示以下错误信息：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">Property &#39;1&#39; is missing in type &#39;[string]&#39; but required in type &#39;[string, boolean]&#39;.</code></pre>\n\n<h4 id=\"2-10-Void-类型\"><a href=\"#2-10-Void-类型\" class=\"headerlink\" title=\"#2.10 Void 类型\"></a>#2.10 Void 类型</h4><p>某种程度上来说，<strong>void</strong> 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 <strong>void</strong>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 声明函数返回值为void\nfunction warnUser(): void &#123;\n  console.log(&quot;This is my warning message&quot;);\n&#125;</code></pre>\n\n<p>以上代码编译生成的 ES5 代码如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&quot;use strict&quot;;\nfunction warnUser() &#123;\n  console.log(&quot;This is my warning message&quot;);\n&#125;</code></pre>\n\n<p>需要注意的是，声明一个void类型的变量没有什么作用，因为在严格模式下，它的值只能为<strong>undefined</strong>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let unusable: void &#x3D; undefined;</code></pre>\n<h4 id=\"2-11-Null-和-Undefined-类型\"><a href=\"#2-11-Null-和-Undefined-类型\" class=\"headerlink\" title=\"#2.11 Null 和 Undefined 类型\"></a>#2.11 Null 和 Undefined 类型</h4><p>ypeScript 里，undefined 和 null 两者有各自的类型分别为 undefined 和 null。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">let u: undefined &#x3D; undefined;\nlet n: null &#x3D; null;</code></pre>\n\n<h4 id=\"2-12-object-Object-和-类型\"><a href=\"#2-12-object-Object-和-类型\" class=\"headerlink\" title=\"#2.12 object, Object 和 {} 类型\"></a>#2.12 object, Object 和 {} 类型</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1.object 类型<br>object类型是：TypeScript2.2 引入的新类型，它用于表示非原始类型。</p></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts\ninterface ObjectConstructor &#123;\n  create(o: object | null): any;\n  &#x2F;&#x2F; ...\n&#125;\n \nconst proto &#x3D; &#123;&#125;;\n \nObject.create(proto);     &#x2F;&#x2F; OK\nObject.create(null);      &#x2F;&#x2F; OK\nObject.create(undefined); &#x2F;&#x2F; Error\nObject.create(1337);      &#x2F;&#x2F; Error\nObject.create(true);      &#x2F;&#x2F; Error\nObject.create(&quot;oops&quot;);    &#x2F;&#x2F; Error</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>2.Object 类型<br>Object 类型：它是所有 Object 类的实例的类型，它由以下两个接口来定义：</p></blockquote>\n<p><strong>Object</strong> 接口定义了 Object.prototype 原型对象上的属性；</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&#x2F;&#x2F; node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts\ninterface Object &#123;\n  constructor: Function;\n  toString(): string;\n  toLocaleString(): string;\n  valueOf(): Object;\n  hasOwnProperty(v: PropertyKey): boolean;\n  isPrototypeOf(v: Object): boolean;\n  propertyIsEnumerable(v: PropertyKey): boolean;\n&#125;</code></pre>\n\n<p>ObjectConstructor 接口定义了 Object 类的属性。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts\ninterface ObjectConstructor &#123;\n  &#x2F;** Invocation via &#96;new&#96; *&#x2F;\n  new(value?: any): Object;\n  &#x2F;** Invocation via function calls *&#x2F;\n  (value?: any): any;\n  readonly prototype: Object;\n  getPrototypeOf(o: any): any;\n  &#x2F;&#x2F; ···\n&#125;\n \ndeclare var Object: ObjectConstructor;</code></pre>\n\n<p>Object 类的所有实例都继承了 Object 接口中的所有属性。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>3.{} 类型<br>{} 类型描述了一个没有成员的对象。当你试图访问这样一个对象的任意属性时，TypeScript 会产生一个编译时错误。</p></blockquote>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; Type &#123;&#125;\nconst obj &#x3D; &#123;&#125;;\n \n&#x2F;&#x2F; Error: Property &#39;prop&#39; does not exist on type &#39;&#123;&#125;&#39;.\nobj.prop &#x3D; &quot;semlinker&quot;;</code></pre>\n<p>但是，你仍然可以使用在 Object 类型上定义的所有属性和方法，这些属性和方法可通过 JavaScript 的原型链隐式地使用：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; Type &#123;&#125;\nconst obj &#x3D; &#123;&#125;;\n \n&#x2F;&#x2F; &quot;[object Object]&quot;\nobj.toString();</code></pre>\n\n<h4 id=\"2-13-Never-类型\"><a href=\"#2-13-Never-类型\" class=\"headerlink\" title=\"#2.13 Never 类型\"></a>#2.13 Never 类型</h4><p>never 类型表示的是那些永不存在的值的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&#x2F;&#x2F; 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never &#123;\n  throw new Error(message);\n&#125;\n \nfunction infiniteLoop(): never &#123;\n  while (true) &#123;&#125;\n&#125;</code></pre>\n<p>在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Foo &#x3D; string | number;\n \nfunction controlFlowAnalysisWithNever(foo: Foo) &#123;\n  if (typeof foo &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n    &#x2F;&#x2F; 这里 foo 被收窄为 string 类型\n  &#125; else if (typeof foo &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;\n    &#x2F;&#x2F; 这里 foo 被收窄为 number 类型\n  &#125; else &#123;\n    &#x2F;&#x2F; foo 在这里是 never\n    const check: never &#x3D; foo;\n  &#125;\n&#125;</code></pre>\n<p>注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Foo &#x3D; string | number | boolean;</code></pre>\n\n<p>然而他忘记同时修改<strong>controlFlowAnalysisWithNever</strong>方法中的控制流程，这时候<strong>else</strong>分支的<strong>foo</strong>类型会被收窄为<strong>boolean</strong>类型，导致无法赋值给 <strong>never</strong>类型，这时就会产生一个编译错误。通过这个方式，我们可以确保<strong>controlFlowAnalysisWithNever</strong> 方法总是穷尽了 <strong>Foo</strong> 的所有可能类型。 通过这个示例，我们可以得出一个结论：使用never避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。</p>\n","feature":true,"text":"前言随着项目越来越大,市面上所使用的五花八门插件库也越来越多,随便一个项目都少说会1w+行代码以上,导致项目维护越来越差。尤其上在开发原生JavaScript的时候从中找Bug更是难如登天。TypeScript犹如the Saviour让更多开发者得心应手,也是现在开发大型工程化...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"TypeScript","slug":"TypeScript","count":1,"path":"api/categories/TypeScript.json"}],"tags":[{"name":"typeScript","slug":"typeScript","count":1,"path":"api/tags/typeScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81TypeScript-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">一、TypeScript 是什么?</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-TypeScript-%E4%B8%8E-JavaScript-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.1 TypeScript 与 JavaScript 的区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E8%8E%B7%E5%8F%96-TypeScript\"><span class=\"toc-text\">1.2 获取 TypeScript</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%AE%89%E8%A3%85-TypeScript\"><span class=\"toc-text\">#1.安装 TypeScript</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E9%AA%8C%E8%AF%81-TypeScript\"><span class=\"toc-text\">#2.验证 TypeScript</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%BC%96%E8%AF%91-TypeScript-%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">#3.编译 TypeScript 文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-%E5%85%B8%E5%9E%8B-TypeScript-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">1.3 典型 TypeScript 工作流程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-TypeScript-%E5%88%9D%E4%BD%93%E9%AA%8C\"><span class=\"toc-text\">1.4 TypeScript 初体验</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81TypeScript-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">二、TypeScript 基础类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-Boolean-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">#2.1 Boolean 类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-Number-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">#2.2 Number 类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-String-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">#2.3 String 类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-Symbol-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">#2.4 Symbol 类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-Array-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">#2.5 Array 类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-6-Enum-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">#2.6 Enum 类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-7-Any-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">#2.7 Any 类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-8-Unknown-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">#2.8 Unknown 类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-9-Tuple-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">#2.9 Tuple 类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-10-Void-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">#2.10 Void 类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-11-Null-%E5%92%8C-Undefined-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">#2.11 Null 和 Undefined 类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-12-object-Object-%E5%92%8C-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">#2.12 object, Object 和 {} 类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-13-Never-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">#2.13 Never 类型</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"络擎","slug":"blog-author","avatar":"https://cdn.ithhx.cn/img-blog/20220224084700.png","link":"/","description":"Think like an artist, develop like an artisan.","socials":{"github":"https://github.com/hehuixiong","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com","csdn":"https://blog.csdn.net","juejin":"https://juejin.cn","customs":{}}},"mapped":true,"prev_post":{"title":"JavaScript中命名约定的最佳实践","uid":"5b57e5b4a1488b082baaa9f5c5285d16","slug":"20220224-javascript-naming","date":"2022-02-24T10:00:00.000Z","updated":"2022-02-26T06:23:34.710Z","comments":true,"path":"api/articles/20220224-javascript-naming.json","keywords":null,"cover":"https://cdn.ithhx.cn/img-blog/20220226142235.png","text":"前言在前端开发过程中，遵循标准的命名约定可以提高代码的可读性。下面就来看看 JavaScript 中命名约定的最佳实践。 1. 变量的命名约定 JavaScript 变量名称是区分大小写的，大写和小写字母是不同的。比如： let DogName &#x3D; &#39;Scoob...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":2,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":1,"path":"api/tags/JavaScript.json"}],"author":{"name":"络擎","slug":"blog-author","avatar":"https://cdn.ithhx.cn/img-blog/20220224084700.png","link":"/","description":"Think like an artist, develop like an artisan.","socials":{"github":"https://github.com/hehuixiong","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com","csdn":"https://blog.csdn.net","juejin":"https://juejin.cn","customs":{}}},"feature":true},"next_post":{"title":"Css实现网页png/svg等透明图片实时变色功能","uid":"4f44e49e46f2e8d19fd85ff6cfc31792","slug":"20211121-css-png-svg","date":"2021-11-21T08:00:00.000Z","updated":"2022-02-24T09:19:32.188Z","comments":true,"path":"api/articles/20211121-css-png-svg.json","keywords":null,"cover":"https://cdn.ithhx.cn/img-blog/20220223175343.png","text":"前言工作中经常会用到各种图标，我们会要求设计师ued同学放到iconfont中，但是有时候iconfont要求比较高，png或者svg图片没有问题，上传到iconfont中有时候会出现异常情况，ued同学很苦恼。iconfont的好处就是可以实时修改图标的颜色。一个图标，多处使用...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"Css","slug":"Css","count":1,"path":"api/categories/Css.json"}],"tags":[{"name":"css","slug":"css","count":2,"path":"api/tags/css.json"}],"author":{"name":"络擎","slug":"blog-author","avatar":"https://cdn.ithhx.cn/img-blog/20220224084700.png","link":"/","description":"Think like an artist, develop like an artisan.","socials":{"github":"https://github.com/hehuixiong","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com","csdn":"https://blog.csdn.net","juejin":"https://juejin.cn","customs":{}}}}}